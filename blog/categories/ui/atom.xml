<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UI | Hackflow]]></title>
  <link href="http://hackflow.com/blog/categories/ui/atom.xml" rel="self"/>
  <link href="http://hackflow.com/"/>
  <updated>2015-09-22T12:57:57+07:00</updated>
  <id>http://hackflow.com/</id>
  <author>
    <name><![CDATA[Alexander Schepanovski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Beyond Decency: Part 2]]></title>
    <link href="http://hackflow.com/blog/2015/04/12/metaprogramming-beyond-decency-part-2/"/>
    <updated>2015-04-12T18:41:00+07:00</updated>
    <id>http://hackflow.com/blog/2015/04/12/metaprogramming-beyond-decency-part-2</id>
    <content type="html"><![CDATA[<p><em>(This is second part of my PiterPy talk adaptation, first part is available <a href="http://hackflow.com/blog/2015/03/29/metaprogramming-beyond-decency/">here</a>)</em></p>

<p>Previously I described various ways AST could be used to alter Python language. Now I will concentrate on translation, and we will translate Python to JavaScript.</p>

<!--more-->


<h2>Translation</h2>

<p>Unlike all Part 1 examples this one started from real need, the one as mundane as form validation:</p>

<p><img src="http://hackflow.com/images/metaprogramming/car-form.png" style="display: block; margin: 0 auto"></p>

<p>Here we have a form with a validation error visible, we typically want this to be shown as soon as possible, so we implement these checks in browser in JavaScript. But we still need to check everything on the server to not let broken data into our database.</p>

<p>Usually we just duplicate logic and this works. Until we get many forms and all of them are like this:</p>

<p><img src="http://hackflow.com/images/metaprogramming/car-form-full.png"></p>

<p>When we arrive to this scale code duplication starts to cause problems duplication always does:
some things are checked only in one place, some things are not updated accordingly and contradict each other. We show weird errors to our users and save broken data to our database.</p>

<p>In ideal world we wish to write every rule just once and then use it in both environments:</p>

<p>```python</p>

<h1>Clean raw value</h1>

<p>clean = lambda x: int(re.sub(r'\s+&lsquo;, &rsquo;&lsquo;, x))</p>

<h1>Validate clean value</h1>

<p>validate = lambda x: 1000 &lt;= x &lt; 100000000
```</p>

<p>So we naturally came to translation. We want to write validation in python, translate it to JavaScript and use on front-end automatically.</p>

<h2>The Easy Part</h2>

<p>Let&rsquo;s start from something simple, like translating a plain lambda like this:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda v: v &lt;= 100)
```</p></blockquote></blockquote></blockquote>

<p>We will use AST to for translation, so first we need to get it for this lambda. It&rsquo;s hard to get source for lambda to parse it, so we&rsquo;ll use <a href="https://github.com/srossross/Meta">meta</a> library to decompile its bytecode:</p>

<p>```python
from meta.decompiler import decompile_func</p>

<p>tree = decompile_func(lambda v: v &lt;= 100)
```</p>

<p>Once we do that we get a tree like this:</p>

<p><img src="http://hackflow.com/images/metaprogramming/rule-tree.dot.svg" style="display: block; margin: 0 auto"></p>

<p>I simplified it to look prettier, but all significant aspects are still here.</p>

<p>The easiest way to render it to a new language is to start from leaves: numbers, variable names and operators mostly look the same in JavaScript. We will employ <code>ast.NodeVisitor</code> to walk the tree:</p>

<p>```python
class Translator(ast.NodeVisitor):</p>

<pre><code>def visit_Num(self, node):
    node.js = str(node.n)

def visit_Name(self, node):
    node.js = 'null' if node.id == 'None' else node.id

def visit_LtE(self, node):
    node.js = '&lt;='
</code></pre>

<p>```</p>

<p>After using this we come to:</p>

<p><img src="http://hackflow.com/images/metaprogramming/translation-1.dot.svg" style="display: block; margin: 0 auto"></p>

<p>When leaf nodes are done we can compile code for ones depending on them:</p>

<p>```python
def visit_Compare(self, node):</p>

<pre><code># Visit sub-nodes
self.generic_visit(node)
# Concatenate sub-node parts,
# use parentheses to not worry about operator precedence
node.js = '(%s %s %s)' % (node.left.js, node.op.js, node.right.js)
</code></pre>

<p>```</p>

<p>And we&rsquo;ve got to:</p>

<p><img src="http://hackflow.com/images/metaprogramming/translation-2.dot.svg" style="display: block; margin: 0 auto"></p>

<p>We can continue going up the tree and finally get:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda v: v &lt;= 100)
function (v) {</p>

<pre><code>return (v &lt;= 100)}
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>Yay! We did it. But&hellip;</p>

<h2>Complications</h2>

<p>What about translating code like:</p>

<p><code>python
1 &lt;= x &lt; 10
</code></p>

<p>There is no chained comparisons in JavaScript, the best we can do is translating this to:</p>

<p><code>js
(1 &lt;= x) &amp;&amp; (x &lt; 10)
</code></p>

<p>There is also no <code>not in</code> operator in JavaScript, combining all that <code>Compare</code> translation complicates to (not necessary to read and understand all this, just appreciate the complication):</p>

<p>```python
def visit_Compare(self, node):</p>

<pre><code>self.generic_visit(node)

ops = node.ops
operands = [node.left] + node.comparators
pairs = pairwise(operands)  # adjacent pairs of operands

node.js = ' &amp;&amp; '.join('%s(%s %s %s)' % \
    ('!' if isinstance(op, ast.NotIn) else '',
        l.js, op.js, r.js)
    for op, (l, r) in zip(ops, pairs))
</code></pre>

<p>```</p>

<p>Another complication is keyword arguments and star arguments. We can deal with them by complecting our code even more or by refusing to handle this case at all:</p>

<p>```python
def visit_Call(self, node):</p>

<pre><code>assert node.kwargs is None \
    and node.starargs is None
# ...
</code></pre>

<p>```</p>

<p>Now we are translating only subset of Python, but this should be okay since translation is not our goal, it&rsquo;s code deduplication for validation rules. So as long as translator works for this particular use case we are fine.</p>

<h2>Closures</h2>

<p>We are still not done yet. We probably don&rsquo;t want to write same validation rules over and over,
so we will end with code like:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>up_to = lambda limit: lambda v: v &lt;= limit
translate(up_to(50))
function (v) {</p>

<pre><code>return (v &lt;= limit)}
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>It&rsquo;s easy to see that <code>limit</code> in JavaScript code refers to non-existing variable. To fix that we need to introspect values enclosed within a function, thankfully Python introspection has our back:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>u50 = up_to(50)
u50.<strong>closure</strong>
(<cell at ...: int object ...>,)
```</p></blockquote></blockquote></blockquote>

<p>Here the closure is a tuple containing single cell with an int object in it. Makes sense since we are enclosing <code>50</code>. It&rsquo;s fairly easy to get cell contents:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>[cell.cell_contents</p>

<pre><code>  for cell in u50.__closure__]
</code></pre>

<p>[50]
```</p></blockquote></blockquote></blockquote>

<p>It&rsquo;s also easy to introspect free variables refering to enclosed values:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>u50.<strong>code</strong>.co_freevars
(&lsquo;limit&rsquo;,)
```</p></blockquote></blockquote></blockquote>

<p>This <code>co_freevars</code> always have the same length and order as cells in closure, so we can pair them up and translate the whole thing to:</p>

<p>```js
(function (){</p>

<pre><code>var limit = 50;

return function (v) {
    return (v &lt;= limit)}
</code></pre>

<p>}())
```</p>

<p>So we&rsquo;ve got a closure. This highlights how we are not really translating functions, but closures,
which are functions plus context.</p>

<h2>More Closures</h2>

<p>Unfortunately <code>func.__closure__</code> doesn&rsquo;t capture everything, any global names and built-ins are still uncovered. Let&rsquo;s translate this one:</p>

<p><code>python
len50 = lambda s: len(s) &lt;= 50
</code></p>

<p>We can access function globals and built-ins namespaces with:</p>

<div class="break-code">
```python
>>> len50.__globals__
{'len50': <function <lambda> at 0x7f705a92a848>, '__builtins__': <module '__builtin__' (built-in)>, 'dis': <module 'dis' from '/usr/lib/python2.7/dis.pyc'>, 'translate': <function js.translate>, 's': '\n<section>\n<pre><code class="python">>>> [cell.cell_contents\n...'

>>> __builtin__.__dict__
{'bytearray': <type 'bytearray'>, 'IndexError': <type 'exceptions.IndexError'>, 'all': <built-in function all>, 'vars': <built-in function vars>, 'SyntaxError': <type 'exceptions.SyntaxError'>, 'isinstance': <built-in function isinstance>, 'copyright': Copyright (c) 2001-2014 Python Software Foundatio...
```
</div>


<p>So we only need to detect global names used by a function. We could have walked the AST, but then we would need to separate local and enclosed non-local names from global ones. The easier way is to introspect bytecode, which looks like this:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>len50.<strong>code</strong>.co_code
&rsquo;t\x00\x00|\x00\x00\x83\x01\x00d\x01\x00k\x01\x00S'
```</p></blockquote></blockquote></blockquote>

<p>Just a binary string, not that pretty. But python standard library provides us <a href="https://docs.python.org/2/library/dis.html">dis</a> module to handle that:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>dis.dis(len50)
1       0 LOAD_GLOBAL         0 (len)</p>

<pre><code>    3 LOAD_FAST           0 (s)
    6 CALL_FUNCTION       1
    9 LOAD_CONST          1 (50)
   12 COMPARE_OP          1 (&lt;=)
   15 RETURN_VALUE
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>The thing to see here is <code>LOAD_GLOBAL</code> instruction, it corresponds to global variable use. <code>dis</code> module only prints bytecode nicely, but doesn&rsquo;t let us really in. So we go for another asset &mdash; <a href="https://pypi.python.org/pypi/byteplay">byteplay</a>:</p>

<p>```python
from byteplay import Code, LOAD_GLOBAL</p>

<h1>Wrap code into byteplay object</h1>

<p>code = Code.from_code(f.<strong>code</strong>)</p>

<h1>Iterate over instructions and collect names</h1>

<p>names = {param for cmd, param in code.code</p>

<pre><code>           if cmd == LOAD_GLOBAL}
</code></pre>

<p>```</p>

<p>So we collected all refered global names, we can translate them unless they are implemented in C.
To handle that we can supply a dict like:</p>

<p>```python
BUILTINS = {</p>

<pre><code>...
len: lambda s: s.length,
...
</code></pre>

<p>}
```</p>

<p>With code which doesn&rsquo;t make sense in Python. However, it will make sense after translation:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda s: len(s) &lt;= 50)
(function (){</p>

<pre><code>var len = function (s) {return s.length};
</code></pre></blockquote></blockquote></blockquote>

<pre><code>return function (s) {
    return (len(s) &lt;= 50)}
</code></pre>

<p>}())
```</p>

<p>Actually we could have used strings in <code>BUILTINS</code> dict, but with lambdas we can refer to other things in our implementations:</p>

<p>```python
BUILTINS = {</p>

<pre><code>...
identity: lambda x: x,
all: lambda seq: seq.every(identity),
...
</code></pre>

<p>}
```</p>

<p>Which enables us to make things like:</p>

<p>```js
(function (){</p>

<pre><code>var all = (function () {
        var identity = function (x) {
            return x};

        return function (seq) {
            return seq.every(identity)}
    }()),
    len = function (s) {return s.length};

return function (xs) {
    return ((len(xs) &gt;= 1) &amp;&amp; all(xs))}
</code></pre>

<p>}())
```</p>

<p>Here <code>all()</code> is defined as a nested closure. Also the whole thing starts to look complex.
Fortunately we don&rsquo;t need to write this, we don&rsquo;t even need to read this, we only deal with
python lambdas. And that one is just a single line for the mess above:</p>

<p><code>python
lambda xs: len(xs) &gt;= 1 and all(xs)
</code></p>

<h2>Meeting Halfway</h2>

<p>We&rsquo;ve already come a long way, however, some things still won&rsquo;t work:</p>

<p>```python</p>

<h1>Does&rsquo;t work, it&rsquo;s s.trim() in JavaScript</h1>

<p>lambda s: s.strip()
```</p>

<p>To fix this we will need to write shims for all python types and convert everything before passing to our function. This sounds like a lot of work, so went another way &mdash; just don&rsquo;t write like that, write this way instead:</p>

<p>```python</p>

<h1>Does work if &ldquo;string&rdquo; is in BUILTINS</h1>

<p>lambda s: string.strip(s)
```</p>

<p>Look, system does many things to make everything work, now we can come along and finally meet halfway. This approach worked wonderfully for us, we managed to get practical solution with:</p>

<ul>
<li>no runtime,</li>
<li>no shims,</li>
<li>only 300 lines of code.</li>
</ul>


<p>Compare this to full-blown python to js translator. Anyway let&rsquo;s see what it have brought to us.</p>

<h2>Demos</h2>

<p>Here is how validation looks. It updates as we type and wholly executed in the browser:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-validation.gif" style="display: block; margin: 0 auto"></p>

<p>And we don&rsquo;t write any JavaScript to achieve that. We write this instead:</p>

<p>```python
class PriceField(FlexField):</p>

<pre><code>clean = lambda v: int(re.sub('\s+', '', v))
rules = [
    [lambda t: re_test(r'^[\s\d]*$', t), 'Enter a number'],
    [lambda v: v &lt; 100000000, 'Specify adequate price'],
    [lambda v: v &gt;= 1000, 'Specify price in rubles, ...'],
]
</code></pre>

<p>```</p>

<p>This works both in browser and server-side so we don&rsquo;t need to duplicate logic or messages. Also having lots of similar fields we can reuse everything: fields, predicates, cleanup functions, rules, which are just lambdas plus text messages. So it really looks like:</p>

<p>```python
class PriceField(FlexField):</p>

<pre><code>clean = clean.posint
rules = [
    rule.posint,
    [test.lt(100000000), 'Specify adequate price'],
    [test.ge(1000), 'Specify price in rubles, ...'],
]
</code></pre>

<p>```</p>

<p>We can also employ inheritance:</p>

<p>```python
class PriceField(PosIntegerField):</p>

<pre><code>rules = ...
</code></pre>

<p>```</p>

<h3>Computed Properties</h3>

<p>We really got more from this system than just validation. And first thing to show is computed properties. These are visibility, labels, choices and more. I&rsquo;ll demo it with another tiny screencast:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-visibility.gif" style="display: block; margin: 0 auto"></p>

<p>Here we can see several aspects &mdash; when user selects &ldquo;exchange to a car&rdquo; a new drop-down appears,
and when a label changes depending on who pays extra. Here is how it looks in code:</p>

<p>```python
class ExtraPaymentField(FlexField):</p>

<pre><code># Relabel depending on who pays extra
label = lambda self: ('Max' if self.exchange_terms = MY_EXTRA else 'Min') \
                     + ' extra payment'
# Show if there is an extra payment involved
visible = lambda self: self.exchange_terms != NO_EXTRA
</code></pre>

<p>```</p>

<p>Additional benefit we get here is that we can compute visibility server-side and do 2 things: first, render a form in an appropriate state from the start (less flickering in the browser) and, second, discard any input we got from invisible fields automatically. Another example of additional benefit is calculated choices, able to get them on back-end we can check if value is one of them.</p>

<p>Other thing to note is that now we have dependencies, e.g. label text and visibility depends on <code>exchange_terms</code> field value. We could have added some tricky introspection, but we instead required programmers to specify dependencies explicitly:</p>

<p>```python
class ExtraPaymentField(FlexField):</p>

<pre><code>@depends('exchange_terms')
def visible(self):
    return self.exchange_terms != NO_EXTRA
</code></pre>

<p>```</p>

<p>This is in line with our meeting halfway principle and it worked this time too.</p>

<h3>Passing Data</h3>

<p>The last demo for today will show how easily we can pass data to client. Here I show how field values could be automatically selected:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-autoselect.gif" style="display: block; margin: 0 auto"></p>

<p>To look through car models we need to pass their list to browser and we can do this simply by enclosing data structure with a function:</p>

<p>```python
models = CarModel.objects.values_list(&lsquo;pk&rsquo;, &lsquo;title&rsquo;)</p>

<p>value = lambda self: first(pk for pk, title in models</p>

<pre><code>                          if self.lookup in title)
</code></pre>

<p>```</p>

<p>This lambda uses <code>models</code> so they are translated to JavaScripts array of arrays and passed along with function. This is very handy when, for example, creating chained selects and under many other circumstances.</p>

<h2>The Bigger System</h2>

<p>You probably already noticed that there is a bigger system besides translator here. These are all its parts:</p>

<ul>
<li>declarative descriptions of fields, models, forms, filters, listings and detail pages,</li>
<li>translation of clean, validate and property compute functions,</li>
<li>transparent data forwarding.</li>
</ul>


<p>There is the thing with tools that when you introduce some new very useful one you get a whole lot of new possibilities, you can make much faster something that took ages previously or you can even do things, which were impossible before.</p>

<p>This also works for developer tools. Introduction of this system had led to a population boom &mdash; we&rsquo;ve got from 7 forms to 51, and you can double that number &lsquo;cause we also autogenerate filtering form for each of them. We also got to 500+ database tables. All of this without loosing our sanity or growing our code base to some insane LOC number.</p>

<h2>Decency</h2>

<p>In python world we have this stigma on metaprogramming. Like it&rsquo;s dirty and should not be used in any serious setting. It&rsquo;s true that this is a complex technique that brings its costs. But as any other consideration this has its limits.</p>

<p>By promoting reasonable considerations to emotional and even kind of religious level we loose an ability to judge it mindfully. We dismiss something even before considering it seriously. And doing so we miss great solutions.</p>

<p>This worked for us. What will do for you?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boiling React Down to a Few Lines in jQuery]]></title>
    <link href="http://hackflow.com/blog/2015/03/08/boiling-react-down-to-few-lines-in-jquery/"/>
    <updated>2015-03-08T20:08:00+07:00</updated>
    <id>http://hackflow.com/blog/2015/03/08/boiling-react-down-to-few-lines-in-jquery</id>
    <content type="html"><![CDATA[<p>You probably heard something like how React is awesome &lsquo;cause it makes UI a pure function of application state? But even before you started to get that it was complemented with something like how that works on top of immutability and virtual DOM? And then you get free save, load, undo and something insane called time-travel debugging on top of that. Guess what? None of these are necessary to use core React idea and reap its benefits. And I&rsquo;ll show that in a few lines in jQuery.</p>

<!--more-->


<p>```html
<span id="colored-counter">0</span>
<input id="color"></input>
<button id="inc"></button></p>

<script>
$('#color').on('keyup', function () {
    $('#colored-counter').css('color', this.value);
})

$('#inc').on('click', function () {
    var oldValue = $('#colored-counter').html();
    var newValue = 1 + Number(oldValue);
    $('#colored-counter').html(newValue);
})
</script>


<p>```</p>

<p>Could be written as:</p>

<p>```html
<span id="colored-counter">0</span>
<input id="color"></input>
<button id="inc"></button></p>

<script>
var state = {color: '', value: 0};

function updateUI() {
    $('#colored-counter').css('color', state.color);
    $('#colored-counter').html(state.value);
}

$('#color').on('keyup', function () {
    state.color = this.value;
    updateUI();
})

$('#inc').on('click', function () {
    state.value++;
    updateUI();
})
</script>


<p>```</p>

<p>This demonstrates React idea in its simplest (and a bit bastardized way). We get to this later, now we should answer a reasonable question: how is this better?
Let me draw you a picture. This is how first variant works:</p>

<p><img src="http://hackflow.com/images/boiling-react-down/jquery-small.svg" style="width: 100%" /></p>

<p>And this is how second one does:</p>

<p><img src="http://hackflow.com/images/boiling-react-down/react-small.svg" style="width: 100%" /></p>

<p>Doesn&rsquo;t look that much better, but let us think scale. Over time our UI will get more events and elements, some events will update more than one element, some elements will be updated by more than one event. So we will get this:</p>

<p><img src="http://hackflow.com/images/boiling-react-down/jquery-big.svg" style="width: 100%" /></p>

<p>And even with our bastardized React-like code we get:</p>

<p><img src="http://hackflow.com/images/boiling-react-down/react-big.svg" style="width: 100%" /></p>

<p>In first picture we have <code>N</code> events, <code>M</code> elements and up to <code>O(N*M)</code> links.
In second one we have just <code>N</code> event links and <code>M</code> element links.
Overall we got from potential <code>O(N*M)</code> complexity down to <code>O(N+M)</code>, not bad for a simple trick.</p>

<p>Now it looks like we got something. But what about all those magical powers?
Ah, we almost got them too.</p>

<h2>Magical Powers</h2>

<p>Basically all magical powers mentioned come from an ability to write:</p>

<p>```js
// save
var cannedState = deepcopy(state);</p>

<p>// load
state = cannedState;
updateUI();
```</p>

<p>This is facilitated by 2 facts:</p>

<ul>
<li>we have a single explicit state,</li>
<li>we can update UI to comply to arbitrary state.</li>
</ul>


<p>That&rsquo;s it. We can write serialized canned state to local storage, send it to server, manage a history of canned states. And this will give us page reload protection, persistence and undo/time-travel respectively.</p>

<p>Confused? Let&rsquo;s write some code. That&rsquo;s how we protect from accidental page reload:</p>

<p>```js
function updateUI() {</p>

<pre><code>// Save latest state to local storage
LocalStorage.set('state', JSON.stringify(state));
// ... continue as usual
</code></pre>

<p>}</p>

<p>// Load saved state from local storage on page load
$(function () {</p>

<pre><code>state = JSON.parse(LocalStorage.get('state'));
updateUI();
</code></pre>

<p>});
```</p>

<p>And that&rsquo;s how we get time-travel debugging:</p>

<p>```html
<span id="time-pos"></span>
<button id="back">Back</button>
<button id="next">Next</button></p>

<script>
var time = {history: [], pos: 0};

function updateTimeUI() {
    $('#time-pos').html('Position ' + time.pos + ' of ' + time.history.length);
}

function saveState() {
    time.history.push(deepcopy(state));
    time.pos++;
    updateTimeUI();
}

$('#back').on('click', function () {
    // Move history pointer
    time.pos--;
    updateTimeUI();
    // Load historic state
    state = deepcopy(time.history[time.pos]);
    updateUI();
})
$('#next').on('click', function () {
    time.pos++;
    // ... same
})

// ...

function updateUI() {
    // Save state to history on every change
    saveState();
    // ... continue as usual
}
</script>


<p>```</p>

<p>On each change of state we push its deep copy to history list and later we can restore that state by simply copying it from history and updating UI to fit it.
I created <a href="http://jsbin.com/fejija/1/edit?js,output">a working clickable demo</a> to illustrate it even more.</p>

<p>Note also how we use the same pattern here? <code>time</code> is the state of time-travel sub-application
and <code>updateTimeUI()</code> is its update function.</p>

<p>Now we can build from that. Undo is just time-travel for user not developer, by saving history to local storage we can preserve it on page reload, by catching errors and sending them along with serialized history to our bug tracker we can automatically reproduce errors our users face.</p>

<p>I should note that React doesn&rsquo;t have all these magical powers, at least out of the box, since it separates app state into pieces and hide it in components.</p>

<h2>Pure Function</h2>

<p>Why do we need pure functions, immutable data and virtual DOM? These are optimizations and to some extent simplifications, not core to idea. Still let&rsquo;s us follow the way that led to them.</p>

<p>First we need a slightly more intricate example:</p>

<p>```html
<span id="count">2</span></p>

<ul>
    <li>hi</li>
    <li>there</li>
</ul>


<p><button id="add"></button></p>

<script>
var state = {items: ['hi', 'there']}

function updateUI() {
    $('#count').html(state.items.length);
    // Compare ul.childNodes to state.items and make updates
    // ...
}

$('ul').on('click', 'li', function () {
    state.items.splice($(this).index(), 1);
    updateUI();
})

$('#add').on('click', function () {
    state.items.push(getNextString());
    updateUI();
})
</script>


<p>```</p>

<p>Several things to see here:</p>

<ul>
<li>there is a duplication between prerendered html and initial state,</li>
<li>update became complex &lsquo;cause we need to compare data structure to DOM.</li>
</ul>


<p>There is a simpler way to do this:</p>

<p>```html</p>

<div id="ui"></div>


<p>&hellip;</p>

<script>
...

function render(state) {
    var span = '<span id="count">' + state.items.length + '</span>';
    var lis = state.items.map(function (item) {
        return '<li>' + item + '</li>';
    });
    return span + '<ul>' + lis.join('') + '</ul>'
}

function updateUI() {
    $('#ui').html(render(state));
}

...
</script>


<p>```</p>

<p>Here <code>render()</code> is just pure function from app state to html. And we want it to be pure so that
state will be the single thing defining UI.</p>

<p>In a way UI was a function of state even in our bastardized code, it just wasn&rsquo;t clearly obvious
&lsquo;cause we updated UI, not calculated and rebuilt it from scratch each time. There also was a possibility to screw up and write <code>updateUI()</code> so that UI state is defined both by its own previous state and application state, thus using render is not really an optimization, but a simplification and a guard.</p>

<p>But anyway that&rsquo;s it on pure functions.</p>

<h2>Virtual DOM</h2>

<p>Now look at those <code>render()</code> / <code>$().html()</code> pair, they build entire representation from scratch on each event, probably on every key press. This sounds slow, so we use another optimization &mdash; virtual DOM:</p>

<p>```js
var root = document.getElementById(&lsquo;ui&rsquo;);
var prevState = state, prevTree = [];</p>

<p>function render(state) {</p>

<pre><code>// Virtual DOM is really just a tree of JavaScript objects or arrays
return [
    ['span', {id: 'count'}, state.items.length],
    ['ul', {}, state.items.map(function (item) {
        return  ['li', {}, item]
    })]
]
</code></pre>

<p>}</p>

<p>function updateUI() {</p>

<pre><code>var vTree = render(state);
var diff = vDiff(prevTree, vTree); // Just a diff on data structures, haha :)
vApply(root, diff)                 // Apply series of patches to real DOM

prevState = deepcopy(state);
prevTree = vTree;
</code></pre>

<p>}
```</p>

<p>If any of this diffing/patching sounds complicated to you then you shouldn&rsquo;t worry React or <a href="https://github.com/Matt-Esch/virtual-dom">standalone virtual DOM implementation</a> got you covered. But that&rsquo;s really not that complicated. If you know how to write diffing algorithm then you can surely implement this yourself.</p>

<p>Note that what we just did is a premature optimization. Current simple example will do just fine
with naive render-to-string implementation above. Surprisingly, most of SPAs out there will do just
fine as well, browsers are hell fast these days. I want to stress this once more &ndash; for an average app you can skip React or other virtual DOM at start and only go for it once it gets too slow (or never).</p>

<p>Another stone in Reacts direction: it&rsquo;s virtual DOM is <a href="http://vdom-benchmark.github.io/vdom-benchmark/">one of the slowest ones</a> across the block.</p>

<h2>Immutability</h2>

<p>Noticed all that <code>deepcopy()</code> calls lying around? This looks like a waste (it really is cheap, but bear with me). The idea behind immutable data structures is to build new state based on previous one instead of copying and then mutating it.</p>

<p>Maybe it is still not clear enough, so I&rsquo;ll show you. That&rsquo;s how we make immutable objects in JS:</p>

<p>```js
var object = {</p>

<pre><code>a: {x: 1, y: 2},
b: {text: 'hi'}
</code></pre>

<p>}</p>

<p>// Now instead of object.a.y = 3 we do
var object2 = {</p>

<pre><code>a: {x: object.a.x, y: 3},
b: object.b
</code></pre>

<p>}
```</p>

<p>Look how we reuse <code>object.a.x</code> and <code>object.b</code>. This not only saves us from copying, but effectively makes diffs way faster: before diffing <code>object.b</code> and <code>object2.b</code> we just check if they are the same object, which is referential equality, and done &mdash; diff is empty, no need to go all the way down.</p>

<p>One thing to add is this naive approach to immutable collections is not only cumbersome, but also ineffective. Suppose you have an object with lots of keys and a value of one of them changes,
you now need to create a new object with all the same keys (you can still reuse values). You probably don&rsquo;t use such objects, but what about array? Let&rsquo;s see how that looks like:</p>

<p><code>js
var prev = ['a', 'b', 'c', ..., 'z'];
var next = prev.slice(0, n-1).concat([newValue]).concat(prev.slice(n));
</code></p>

<p>So we need to copy the whole thing. Here is a better way to implement immutable sequences:</p>

<p>```js
var prev = {</p>

<pre><code>'0-3': {
    '0-1': {0: 'a', 1: 'b'},
    '2-3': {...},
},
'4-7': {...}
</code></pre>

<p>}
var next = {</p>

<pre><code>'0-3': {
    '0-1': prev['0-3']['0-1'],
    '2-3': {
        2: 'hey',
        3: prev['0-3']['2-3'][3]
    }
},
'4-7': prev['4-7']
</code></pre>

<p>}
```</p>

<p>We can see that we only create <code>log N</code> new objects here and the rest is reused, so even less copying and faster diffs. You also don&rsquo;t need to really deal with all this trees. There are great ready to use implementations out there. E.g. this is how our first example looks with a help of
<a href="https://github.com/facebook/immutable-js">Immutable.js</a>:</p>

<p>```js
var object = Immutable.fromJS({</p>

<pre><code>a: {x: 1, y: 2},
b: {text: 'hi'}
</code></pre>

<p>})</p>

<p>var object2 = object.setIn([&lsquo;a&rsquo;, &lsquo;y&rsquo;], 3); // object remains intact
```</p>

<p>It gives you nice API, efficiency and protection against accidentally writing to supposed to be immutable collection. Also take a look at <a href="https://github.com/swannodette/mori">mori</a> &mdash; a set of immutable collections extracted from ClojureScript.</p>

<p>Note that React actually uses naive immutable by convention collections.</p>

<h2>Wrap-up</h2>

<p>It may look from my notes that React is not a good tool, but it is actually very useful one.
It may not have magical powers and top speed, but it got components and is still pretty fast. It also offers ecosystem and community.</p>

<p>And there is one more way to look at it. React made a significant push to front-end development in an interesting direction, including all those virtual DOMs and immutable collection libraries.</p>

<p>Anyway, now that you know all this, you can judge better on what to use and how to structure your code.</p>
]]></content>
  </entry>
  
</feed>
