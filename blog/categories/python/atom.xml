<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Hackflow]]></title>
  <link href="http://Suor.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://Suor.github.io/"/>
  <updated>2013-10-07T21:30:32+08:00</updated>
  <id>http://Suor.github.io/</id>
  <author>
    <name><![CDATA[Alexander Schepanovski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Python Made Easy]]></title>
    <link href="http://Suor.github.io/blog/2013/10/07/functional-python-made-easy/"/>
    <updated>2013-10-07T18:02:00+08:00</updated>
    <id>http://Suor.github.io/blog/2013/10/07/functional-python-made-easy</id>
    <content type="html"><![CDATA[<p>Не ещё одна статья о функциональном программировании.</p>

<p>Вот уже несколько лет функциональное программирование набирает популярность. Это, конечно, не значит, что люди забрасывают свои старые языки и ООП и массово переходят на Haskell, Lisp или Erlang. Нет. Функциональная парадигма проникает в наш код через лазейки мультипарадигменных языков, а вышеупомянутые языки чаще служат флагами в этом наступлении, чем используются непосредственно.</p>

<p>Я собирался продолжить в том же духе и во второй части статьи представить <a href="http://github.com/Suor/funcy">свою библиотеку</a>, добавляющую пару функциональных трюков в python, при этом потом понял, что фокус моей библиотеки не на функциональном программировании, а на практичности. На этом я и сосредоточюсь, приведу несколько жизненных примеров полезности funcy.
<habracut />
Разработка funcy началась с попытки собрать в кучу несколько утилит для манипулирования данными и реже функциями, поэтому большинство моих примеров будут сосредоточены именно на этом. Возможно, некоторые (или многие) примеры покажутся тривиальными, но удивительно сколько времени могут сэкономить такие простые функции и насколько более выразительным они могут сделать ваш код.</p>

<p>Я пройдусь по нескольким типичным задачам, которые встречаются в питоньей практике, и несмотря на свою незамысловатость, вызывают постоянные вопросы. Итак, поехали.</p>

<h4>Несложные манипуляции с данными</h4>


<ol>
<li>Объединить список списков. Традиционно я делал это таким образом:</li>
</ol>


<p><source lang="python">
from operator import concat
reduce(concat, list_of_lists)</p>

<h1>Или таким:</h1>

<p>sum(list_of_lists, [])</p>

<h1>Или таким:</h1>

<p>from itertools import chain
list(chain.from_iterable(list_of_lists))
</source>
Все они неплохи, но требуют либо лишних телодвижений: импорты и дополнительные вызовы, либо накладывают ограничения: объединять можно только списки со списками и туплы с туплами, для суммы нужно ещё знать заранее какой тип придёт. В funcy это делается так:</p>

<p><source lang="python">
from funcy import cat
cat(list_of_lists)
</source>
<code>cat()</code> объединяет список списков, кортежей, итераторов да и вообще любых итерируемых в один список. Если нужно объединить списки результатов вызова функции, то можно воспользоваться <code>mapcat()</code>, например:</p>

<p><source lang="python">
from funcy import mapcat
mapcat(str.splitlines, bunch_of_texts)
</source>
разберёт все строки в текстах в один плоский список. Для обеих функций есть ленивые версии: <code>icat()</code> и <code>imapcat()</code>.</p>

<ol>
<li>Сложить несколько словарей. В питоне есть несколько неуклюжих способов объединять словари:</li>
</ol>


<p><source lang="python">
d1.update(d2)  # Изменяет d1
dict(d1, **d2) # Неудобно для > 2 словарей</p>

<p>d = d1.copy()
d.update(d2)
</source>
Я всегда удивлялся почему их нельзя просто сложить? Но имеем то, что имеем. В любом случае, с funcy это делается легко:</p>

<p><source lang="python">
from funcy import merge, join
merge(d1, d2)
merge(d1, d2, d3)
join(sequence_of_dicts)
</source>
Но <code>merge()</code> и <code>join()</code> могут объединять не только словари, они работают практически для любых коллекций: словарей, упорядоченных словарей, множеств, списков, кортежей, итераторов и даже строк.</p>

<ol>
<li>Захват подстроки с помощью регулярного выражения. Обычно это делается так:</li>
</ol>


<p><source lang="python">
m = re.search(some_re, s)
if m:</p>

<pre><code>actual_match = m.group() # или m.group(i), или m.groups()
...
</code></pre>

<p></source>
С funcy это превращается в:</p>

<p><source lang="python">
from funcy import re_find
actual_match = re_find(some_re, s)
</source>
Если это не кажется вам достаточно впечатляющим, то взгляните на это:</p>

<p><source lang="python">
from funcy import re_finder, re_all, partial, mapcat</p>

<h1>Вычленяем числа из каждого слова</h1>

<p>map(re_finder(&lsquo;\d+&rsquo;), words)</p>

<h1>Парсим ini файл (re_finder() возвращает кортежи когда в выражении > 1 захвата)</h1>

<p>dict(imap(re_finder(&lsquo;(\w+)=(\w+)&rsquo;), ini.splitlines()))</p>

<h1>Вычленяем числа из строк (возможно по нескольку из каждой) и объединяем в плоский список</h1>

<p>mapcat(partial(re_all, r'\d+&lsquo;), bunch_of_strings)
</source></p>

<h4>Отступление про импорты и практичность</h4>


<p>Как вы могли заметить, я импортирую функции напрямую из funcy, не используя какие-либо подпакеты. Причина, по которой я остановился на таком интерфейсе, &ndash; практичность; было бы довольно занудным требовать от всех пользователей моей библиотеки помнить откуда нужно импортировать walk() из funcy.colls или funcy.seqs, кроме того, многострочные импорты в начале каждого файла и без меня есть кому набивать.</p>

<p>Дополнительным преимуществом такого решения является возможность просто написать:</p>

<p><source lang="python">
from funcy import *
</source>
И наслаждаться всеми функциональными прелестями и удобством, что приносит funcy, более не возвращаясь в начало файла за добавкой. Что ж, теперь, когда вы знаете где лежит всё добро, я больше не буду явно указывать импорты из funcy. Продолжим.</p>

<h4>Кое-какие более функциональные штучки</h4>


<p>Мы уже видели пару примеров использования функций высшего порядка &ndash; <code>re_finder()</code> и <code>partial()</code>. Стоит добавить, что сама функция <code>re_finder()</code> является частичным применением <code>re_find()</code> созданным для удобства применения в <code>map()</code> и ей подобных. И естественным образом, с <code>filter()</code> удобно использовать <code>re_tester()</code>:</p>

<p><source lang="python"></p>

<h1>Выбираем все приватные атрибуты объекта</h1>

<p>is_private = re_tester(&lsquo;^_&rsquo;)
filter(is_private, dir(some_obj))
</source>
Отлично, мы можем задать несколько предикатов, таких как <code>is_private()</code>, и фильтровать атрибуты объекта по ним:</p>

<p><source lang="python">
is_special = re_tester(&lsquo;^<strong>.+</strong>$&rsquo;)
is_const = re_tester(&lsquo;^[A-Z_]+$&rsquo;)
filter(&hellip;)
</source>
Но, что если мы хотим получить список публичных атрибутов или приватных констант, что-то задействующее комбинацию предикатов? Легко:</p>

<p><source lang="python">
is_public = complement(is_private)
is_private_const = all_fn(is_private, is_const)
either_const_or_public = any_fn(is_const, is_public)
</source>
Для удобства также есть функция, дополняющая <code>filter()</code>:</p>

<p><source lang="python">
remove(is_private, &hellip;) # то же, что filter(is_public)
</source>
Надеюсь все утолили свой функциональный аппетит, потому пора перейти к чему-нибудь менее абстрактному.</p>

<h4>Работа с коллекциями</h4>


<p>Кроме утилит для работы с последовательностями, <a href="http://funcy.readthedocs.org/en/latest/seqs.html">коих много больше</a>, чем я тут описал, funcy также помогает работать с коллекциями. Основу составляют функции <code>walk()</code> и <code>select()</code>, которые аналогичны <code>map()</code> и <code>filter()</code>, но сохраняют тип обрабатываемой коллекции:</p>

<p><source lang="python">
walk(inc, {1, 2, 3}) # &ndash;> {2, 3, 4}
walk(inc, (1, 2, 3)) # &ndash;> (2, 3, 4)</p>

<h1>при обработке словаря мы работаем с парами ключ-значение</h1>

<p>swap = lambda (k, v): (v, k)
walk(swap, {1: 10, 2: 20})</p>

<h1>&ndash;> {10: 1, 20: 2}</h1>

<p>select(even, {1, 2, 3, 10, 20})</p>

<h1>&ndash;> {2, 10, 20}</h1>

<p>select(lambda (k, v): k == v, {1: 1, 2: 3})</p>

<h1>&ndash;> {1: 1}</h1>

<p></source>
Эта пара функций подкрепляется набором для работы со словарями: <code>walk_keys(), walk_values(), select_keys(), select_values()</code>:</p>

<p><source lang="python"></p>

<h1>выберем публичную часть словаря атрибутов объекта</h1>

<p>select_keys(is_public, instance.<strong>dict</strong>)</p>

<h1>выбросим ложные значения из словаря</h1>

<p>select_values(bool, some_dict)
</source>
Последний пример из этой серии будет использовать сразу несколько новых функций: <code>silent()</code> &ndash; глушит все исключения, бросаемые оборачиваемой функцией, возвращая <code>None</code>; <code>compact()</code> &ndash; убирает из коллекции значения <code>None</code>; <code>walk_values()</code> &ndash; обходит значения переданного словаря, конструируя новый словарь с значениями, преобразованными переданной функцией. В целом эта строка выбирает словарь целочисленных параметров из параметров запроса:</p>

<p><source lang="python">
compact(walk_values(silent(int), request_dict))
</source></p>

<h4>Манипулирование данными</h4>


<p>О! Мы добрались до самого интересного, сюда часть примеров я включил просто потому, что они кажутся мне клёвыми. Хотя, если честно, я делал это и выше. Сейчас мы будем разделять и группировать:</p>

<p><source lang="python"></p>

<h1>отделим абсолютные URL от относительных</h1>

<p>absolute, relative = split(re_tester(r'^<a href="http://">http://</a>&lsquo;), urls)</p>

<h1>группируем посты по категории</h1>

<p>group_by(lambda post: post.category, posts)
</source>
Собирать плоские данные во вложенные структуры:</p>

<p><source lang="python"></p>

<h1>строим словарь из плоского списка пар</h1>

<p>dict(partition(2, flat_list_of_pairs))</p>

<h1>строим структуру учётных данных</h1>

<p>{id: (name, password) for id, name, password in partition(3, users)}</p>

<h1>проверяем, что список версий последователен</h1>

<p>assert all(prev + 1 == next for prev, next in partition(2, 1, versions)):</p>

<h1>обрабатываем данные кусками</h1>

<p>for chunk in chunks(CHUNK_SIZE, lots_of_data):</p>

<pre><code>process(chunk)
</code></pre>

<p></source>
И ещё пара примеров, просто до кучи:</p>

<p><source lang="python"></p>

<h1>выделяем абзацы красной строкой</h1>

<p>for line, prev in with_prev(text.splitlines()):</p>

<pre><code>if not prev:
    print '    ',
print line
</code></pre>

<h1>выбираем пьесы Шекспира за 1611 год</h1>

<p>where(plays, author=&ldquo;Shakespeare&rdquo;, year=1611)</p>

<h1>=> [{&ldquo;title&rdquo;: &ldquo;Cymbeline&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611},</h1>

<h1>{&ldquo;title&rdquo;: &ldquo;The Tempest&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611}]</h1>

<p></source></p>

<h4>Не просто библиотека</h4>


<p>Возможно, некоторые из вас встретили знакомые функции из Clojure и Underscore.js (кстати, пример с Шекспиром нагло содран из документации последней), &ndash; ничего удивительного, я во многом черпал вдохновение из этих источников. При этом я старался следовать питоньему стилю, сохранять консистентность библиотеки и нигде не жертвовать практичностью, поэтому не все функции полностью соответствуют своим прототипам, они скорее соответствуют друг другу и стандартной библиотеке.</p>

<p>И ещё одна мысль. Мы привыкли называть языки программирования языками, но редко осознаём, что синтаксические конструкции и стандартные функции &ndash; это слова этих языков. Мы можем добавлять свои слова, определяя функции, но обычно такие слова слишком специфичны, чтобы попасть в повседневный языковой словарь. Утилиты из funcy, напротив, заточены под широкую область применения, поэтому эту библиотеку можно воспринимать как расширение python, также как underscore или jQuery &ndash; расширение JavaScript. Итак, всем кто хочет пополнить свой словарный запас &ndash; <a href="http://github.com/Suor/funcy">добро пожаловать</a>.</p>

<p>Я уже упоминал, про использование funcy в стиле from funcy import *. Кто-то может сказать, что это дурной стиль, так мы засоряем пространство имён, но на это можно смотреть иначе: если рассматиривать funcy не как библиотеку это тот язык, на котором мы пишем</p>

<p>@cached_property</p>

<p>@staticmethod
@memoize.lookup
def user_to_source():</p>

<pre><code>return ImportSource.objects.filter(enabled=True, car_offer=True) \
                           .values_list('user_id', 'id')
</code></pre>
]]></content>
  </entry>
  
</feed>
