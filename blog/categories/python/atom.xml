<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Hackflow]]></title>
  <link href="http://hackflow.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://hackflow.com/"/>
  <updated>2015-10-31T17:51:54+07:00</updated>
  <id>http://hackflow.com/</id>
  <author>
    <name><![CDATA[Alexander Schepanovski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Beyond Decency: Part 2]]></title>
    <link href="http://hackflow.com/blog/2015/04/12/metaprogramming-beyond-decency-part-2/"/>
    <updated>2015-04-12T18:41:00+07:00</updated>
    <id>http://hackflow.com/blog/2015/04/12/metaprogramming-beyond-decency-part-2</id>
    <content type="html"><![CDATA[<p><em>(This is second part of my PiterPy talk adaptation, first part is available <a href="http://hackflow.com/blog/2015/03/29/metaprogramming-beyond-decency/">here</a>)</em></p>

<p>Previously I described various ways AST could be used to alter Python language. Now I will concentrate on translation, and we will translate Python to JavaScript.</p>

<!--more-->


<h2>Translation</h2>

<p>Unlike all Part 1 examples this one started from real need, the one as mundane as form validation:</p>

<p><img src="http://hackflow.com/images/metaprogramming/car-form.png" style="display: block; margin: 0 auto"></p>

<p>Here we have a form with a validation error visible, we typically want this to be shown as soon as possible, so we implement these checks in browser in JavaScript. But we still need to check everything on the server to not let broken data into our database.</p>

<p>Usually we just duplicate logic and this works. Until we get many forms and all of them are like this:</p>

<p><img src="http://hackflow.com/images/metaprogramming/car-form-full.png"></p>

<p>When we arrive to this scale code duplication starts to cause problems duplication always does:
some things are checked only in one place, some things are not updated accordingly and contradict each other. We show weird errors to our users and save broken data to our database.</p>

<p>In ideal world we wish to write every rule just once and then use it in both environments:</p>

<p>```python</p>

<h1>Clean raw value</h1>

<p>clean = lambda x: int(re.sub(r'\s+&lsquo;, &rsquo;&lsquo;, x))</p>

<h1>Validate clean value</h1>

<p>validate = lambda x: 1000 &lt;= x &lt; 100000000
```</p>

<p>So we naturally came to translation. We want to write validation in python, translate it to JavaScript and use on front-end automatically.</p>

<h2>The Easy Part</h2>

<p>Let&rsquo;s start from something simple, like translating a plain lambda like this:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda v: v &lt;= 100)
```</p></blockquote></blockquote></blockquote>

<p>We will use AST to for translation, so first we need to get it for this lambda. It&rsquo;s hard to get source for lambda to parse it, so we&rsquo;ll use <a href="https://github.com/srossross/Meta">meta</a> library to decompile its bytecode:</p>

<p>```python
from meta.decompiler import decompile_func</p>

<p>tree = decompile_func(lambda v: v &lt;= 100)
```</p>

<p>Once we do that we get a tree like this:</p>

<p><img src="http://hackflow.com/images/metaprogramming/rule-tree.dot.svg" style="display: block; margin: 0 auto"></p>

<p>I simplified it to look prettier, but all significant aspects are still here.</p>

<p>The easiest way to render it to a new language is to start from leaves: numbers, variable names and operators mostly look the same in JavaScript. We will employ <code>ast.NodeVisitor</code> to walk the tree:</p>

<p>```python
class Translator(ast.NodeVisitor):</p>

<pre><code>def visit_Num(self, node):
    node.js = str(node.n)

def visit_Name(self, node):
    node.js = 'null' if node.id == 'None' else node.id

def visit_LtE(self, node):
    node.js = '&lt;='
</code></pre>

<p>```</p>

<p>After using this we come to:</p>

<p><img src="http://hackflow.com/images/metaprogramming/translation-1.dot.svg" style="display: block; margin: 0 auto"></p>

<p>When leaf nodes are done we can compile code for ones depending on them:</p>

<p>```python
def visit_Compare(self, node):</p>

<pre><code># Visit sub-nodes
self.generic_visit(node)
# Concatenate sub-node parts,
# use parentheses to not worry about operator precedence
node.js = '(%s %s %s)' % (node.left.js, node.op.js, node.right.js)
</code></pre>

<p>```</p>

<p>And we&rsquo;ve got to:</p>

<p><img src="http://hackflow.com/images/metaprogramming/translation-2.dot.svg" style="display: block; margin: 0 auto"></p>

<p>We can continue going up the tree and finally get:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda v: v &lt;= 100)
function (v) {</p>

<pre><code>return (v &lt;= 100)}
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>Yay! We did it. But&hellip;</p>

<h2>Complications</h2>

<p>What about translating code like:</p>

<p><code>python
1 &lt;= x &lt; 10
</code></p>

<p>There is no chained comparisons in JavaScript, the best we can do is translating this to:</p>

<p><code>js
(1 &lt;= x) &amp;&amp; (x &lt; 10)
</code></p>

<p>There is also no <code>not in</code> operator in JavaScript, combining all that <code>Compare</code> translation complicates to (not necessary to read and understand all this, just appreciate the complication):</p>

<p>```python
def visit_Compare(self, node):</p>

<pre><code>self.generic_visit(node)

ops = node.ops
operands = [node.left] + node.comparators
pairs = pairwise(operands)  # adjacent pairs of operands

node.js = ' &amp;&amp; '.join('%s(%s %s %s)' % \
    ('!' if isinstance(op, ast.NotIn) else '',
        l.js, op.js, r.js)
    for op, (l, r) in zip(ops, pairs))
</code></pre>

<p>```</p>

<p>Another complication is keyword arguments and star arguments. We can deal with them by complecting our code even more or by refusing to handle this case at all:</p>

<p>```python
def visit_Call(self, node):</p>

<pre><code>assert node.kwargs is None \
    and node.starargs is None
# ...
</code></pre>

<p>```</p>

<p>Now we are translating only subset of Python, but this should be okay since translation is not our goal, it&rsquo;s code deduplication for validation rules. So as long as translator works for this particular use case we are fine.</p>

<h2>Closures</h2>

<p>We are still not done yet. We probably don&rsquo;t want to write same validation rules over and over,
so we will end with code like:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>up_to = lambda limit: lambda v: v &lt;= limit
translate(up_to(50))
function (v) {</p>

<pre><code>return (v &lt;= limit)}
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>It&rsquo;s easy to see that <code>limit</code> in JavaScript code refers to non-existing variable. To fix that we need to introspect values enclosed within a function, thankfully Python introspection has our back:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>u50 = up_to(50)
u50.<strong>closure</strong>
(<cell at ...: int object ...>,)
```</p></blockquote></blockquote></blockquote>

<p>Here the closure is a tuple containing single cell with an int object in it. Makes sense since we are enclosing <code>50</code>. It&rsquo;s fairly easy to get cell contents:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>[cell.cell_contents</p>

<pre><code>  for cell in u50.__closure__]
</code></pre>

<p>[50]
```</p></blockquote></blockquote></blockquote>

<p>It&rsquo;s also easy to introspect free variables refering to enclosed values:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>u50.<strong>code</strong>.co_freevars
(&lsquo;limit&rsquo;,)
```</p></blockquote></blockquote></blockquote>

<p>This <code>co_freevars</code> always have the same length and order as cells in closure, so we can pair them up and translate the whole thing to:</p>

<p>```js
(function (){</p>

<pre><code>var limit = 50;

return function (v) {
    return (v &lt;= limit)}
</code></pre>

<p>}())
```</p>

<p>So we&rsquo;ve got a closure. This highlights how we are not really translating functions, but closures,
which are functions plus context.</p>

<h2>More Closures</h2>

<p>Unfortunately <code>func.__closure__</code> doesn&rsquo;t capture everything, any global names and built-ins are still uncovered. Let&rsquo;s translate this one:</p>

<p><code>python
len50 = lambda s: len(s) &lt;= 50
</code></p>

<p>We can access function globals and built-ins namespaces with:</p>

<div class="break-code">
```python
>>> len50.__globals__
{'len50': <function <lambda> at 0x7f705a92a848>, '__builtins__': <module '__builtin__' (built-in)>, 'dis': <module 'dis' from '/usr/lib/python2.7/dis.pyc'>, 'translate': <function js.translate>, 's': '\n<section>\n<pre><code class="python">>>> [cell.cell_contents\n...'

>>> __builtin__.__dict__
{'bytearray': <type 'bytearray'>, 'IndexError': <type 'exceptions.IndexError'>, 'all': <built-in function all>, 'vars': <built-in function vars>, 'SyntaxError': <type 'exceptions.SyntaxError'>, 'isinstance': <built-in function isinstance>, 'copyright': Copyright (c) 2001-2014 Python Software Foundatio...
```
</div>


<p>So we only need to detect global names used by a function. We could have walked the AST, but then we would need to separate local and enclosed non-local names from global ones. The easier way is to introspect bytecode, which looks like this:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>len50.<strong>code</strong>.co_code
&rsquo;t\x00\x00|\x00\x00\x83\x01\x00d\x01\x00k\x01\x00S'
```</p></blockquote></blockquote></blockquote>

<p>Just a binary string, not that pretty. But python standard library provides us <a href="https://docs.python.org/2/library/dis.html">dis</a> module to handle that:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>dis.dis(len50)
1       0 LOAD_GLOBAL         0 (len)</p>

<pre><code>    3 LOAD_FAST           0 (s)
    6 CALL_FUNCTION       1
    9 LOAD_CONST          1 (50)
   12 COMPARE_OP          1 (&lt;=)
   15 RETURN_VALUE
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>The thing to see here is <code>LOAD_GLOBAL</code> instruction, it corresponds to global variable use. <code>dis</code> module only prints bytecode nicely, but doesn&rsquo;t let us really in. So we go for another asset &mdash; <a href="https://pypi.python.org/pypi/byteplay">byteplay</a>:</p>

<p>```python
from byteplay import Code, LOAD_GLOBAL</p>

<h1>Wrap code into byteplay object</h1>

<p>code = Code.from_code(f.<strong>code</strong>)</p>

<h1>Iterate over instructions and collect names</h1>

<p>names = {param for cmd, param in code.code</p>

<pre><code>           if cmd == LOAD_GLOBAL}
</code></pre>

<p>```</p>

<p>So we collected all refered global names, we can translate them unless they are implemented in C.
To handle that we can supply a dict like:</p>

<p>```python
BUILTINS = {</p>

<pre><code>...
len: lambda s: s.length,
...
</code></pre>

<p>}
```</p>

<p>With code which doesn&rsquo;t make sense in Python. However, it will make sense after translation:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>translate(lambda s: len(s) &lt;= 50)
(function (){</p>

<pre><code>var len = function (s) {return s.length};
</code></pre></blockquote></blockquote></blockquote>

<pre><code>return function (s) {
    return (len(s) &lt;= 50)}
</code></pre>

<p>}())
```</p>

<p>Actually we could have used strings in <code>BUILTINS</code> dict, but with lambdas we can refer to other things in our implementations:</p>

<p>```python
BUILTINS = {</p>

<pre><code>...
identity: lambda x: x,
all: lambda seq: seq.every(identity),
...
</code></pre>

<p>}
```</p>

<p>Which enables us to make things like:</p>

<p>```js
(function (){</p>

<pre><code>var all = (function () {
        var identity = function (x) {
            return x};

        return function (seq) {
            return seq.every(identity)}
    }()),
    len = function (s) {return s.length};

return function (xs) {
    return ((len(xs) &gt;= 1) &amp;&amp; all(xs))}
</code></pre>

<p>}())
```</p>

<p>Here <code>all()</code> is defined as a nested closure. Also the whole thing starts to look complex.
Fortunately we don&rsquo;t need to write this, we don&rsquo;t even need to read this, we only deal with
python lambdas. And that one is just a single line for the mess above:</p>

<p><code>python
lambda xs: len(xs) &gt;= 1 and all(xs)
</code></p>

<h2>Meeting Halfway</h2>

<p>We&rsquo;ve already come a long way, however, some things still won&rsquo;t work:</p>

<p>```python</p>

<h1>Does&rsquo;t work, it&rsquo;s s.trim() in JavaScript</h1>

<p>lambda s: s.strip()
```</p>

<p>To fix this we will need to write shims for all python types and convert everything before passing to our function. This sounds like a lot of work, so went another way &mdash; just don&rsquo;t write like that, write this way instead:</p>

<p>```python</p>

<h1>Does work if &ldquo;string&rdquo; is in BUILTINS</h1>

<p>lambda s: string.strip(s)
```</p>

<p>Look, system does many things to make everything work, now we can come along and finally meet halfway. This approach worked wonderfully for us, we managed to get practical solution with:</p>

<ul>
<li>no runtime,</li>
<li>no shims,</li>
<li>only 300 lines of code.</li>
</ul>


<p>Compare this to full-blown python to js translator. Anyway let&rsquo;s see what it have brought to us.</p>

<h2>Demos</h2>

<p>Here is how validation looks. It updates as we type and wholly executed in the browser:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-validation.gif" style="display: block; margin: 0 auto"></p>

<p>And we don&rsquo;t write any JavaScript to achieve that. We write this instead:</p>

<p>```python
class PriceField(FlexField):</p>

<pre><code>clean = lambda v: int(re.sub('\s+', '', v))
rules = [
    [lambda t: re_test(r'^[\s\d]*$', t), 'Enter a number'],
    [lambda v: v &lt; 100000000, 'Specify adequate price'],
    [lambda v: v &gt;= 1000, 'Specify price in rubles, ...'],
]
</code></pre>

<p>```</p>

<p>This works both in browser and server-side so we don&rsquo;t need to duplicate logic or messages. Also having lots of similar fields we can reuse everything: fields, predicates, cleanup functions, rules, which are just lambdas plus text messages. So it really looks like:</p>

<p>```python
class PriceField(FlexField):</p>

<pre><code>clean = clean.posint
rules = [
    rule.posint,
    [test.lt(100000000), 'Specify adequate price'],
    [test.ge(1000), 'Specify price in rubles, ...'],
]
</code></pre>

<p>```</p>

<p>We can also employ inheritance:</p>

<p>```python
class PriceField(PosIntegerField):</p>

<pre><code>rules = ...
</code></pre>

<p>```</p>

<h3>Computed Properties</h3>

<p>We really got more from this system than just validation. And first thing to show is computed properties. These are visibility, labels, choices and more. I&rsquo;ll demo it with another tiny screencast:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-visibility.gif" style="display: block; margin: 0 auto"></p>

<p>Here we can see several aspects &mdash; when user selects &ldquo;exchange to a car&rdquo; a new drop-down appears,
and when a label changes depending on who pays extra. Here is how it looks in code:</p>

<p>```python
class ExtraPaymentField(FlexField):</p>

<pre><code># Relabel depending on who pays extra
label = lambda self: ('Max' if self.exchange_terms = MY_EXTRA else 'Min') \
                     + ' extra payment'
# Show if there is an extra payment involved
visible = lambda self: self.exchange_terms != NO_EXTRA
</code></pre>

<p>```</p>

<p>Additional benefit we get here is that we can compute visibility server-side and do 2 things: first, render a form in an appropriate state from the start (less flickering in the browser) and, second, discard any input we got from invisible fields automatically. Another example of additional benefit is calculated choices, able to get them on back-end we can check if value is one of them.</p>

<p>Other thing to note is that now we have dependencies, e.g. label text and visibility depends on <code>exchange_terms</code> field value. We could have added some tricky introspection, but we instead required programmers to specify dependencies explicitly:</p>

<p>```python
class ExtraPaymentField(FlexField):</p>

<pre><code>@depends('exchange_terms')
def visible(self):
    return self.exchange_terms != NO_EXTRA
</code></pre>

<p>```</p>

<p>This is in line with our meeting halfway principle and it worked this time too.</p>

<h3>Passing Data</h3>

<p>The last demo for today will show how easily we can pass data to client. Here I show how field values could be automatically selected:</p>

<p><img src="http://hackflow.com/images/metaprogramming/demo-autoselect.gif" style="display: block; margin: 0 auto"></p>

<p>To look through car models we need to pass their list to browser and we can do this simply by enclosing data structure with a function:</p>

<p>```python
models = CarModel.objects.values_list(&lsquo;pk&rsquo;, &lsquo;title&rsquo;)</p>

<p>value = lambda self: first(pk for pk, title in models</p>

<pre><code>                          if self.lookup in title)
</code></pre>

<p>```</p>

<p>This lambda uses <code>models</code> so they are translated to JavaScripts array of arrays and passed along with function. This is very handy when, for example, creating chained selects and under many other circumstances.</p>

<h2>The Bigger System</h2>

<p>You probably already noticed that there is a bigger system besides translator here. These are all its parts:</p>

<ul>
<li>declarative descriptions of fields, models, forms, filters, listings and detail pages,</li>
<li>translation of clean, validate and property compute functions,</li>
<li>transparent data forwarding.</li>
</ul>


<p>There is the thing with tools that when you introduce some new very useful one you get a whole lot of new possibilities, you can make much faster something that took ages previously or you can even do things, which were impossible before.</p>

<p>This also works for developer tools. Introduction of this system had led to a population boom &mdash; we&rsquo;ve got from 7 forms to 51, and you can double that number &lsquo;cause we also autogenerate filtering form for each of them. We also got to 500+ database tables. All of this without loosing our sanity or growing our code base to some insane LOC number.</p>

<h2>Decency</h2>

<p>In python world we have this stigma on metaprogramming. Like it&rsquo;s dirty and should not be used in any serious setting. It&rsquo;s true that this is a complex technique that brings its costs. But as any other consideration this has its limits.</p>

<p>By promoting reasonable considerations to emotional and even kind of religious level we loose an ability to judge it mindfully. We dismiss something even before considering it seriously. And doing so we miss great solutions.</p>

<p>This worked for us. What will do for you?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Beyond Decency: Part 1]]></title>
    <link href="http://hackflow.com/blog/2015/03/29/metaprogramming-beyond-decency/"/>
    <updated>2015-03-29T20:08:00+07:00</updated>
    <id>http://hackflow.com/blog/2015/03/29/metaprogramming-beyond-decency</id>
    <content type="html"><![CDATA[<p><em>(This an adaptation of a talk I gave at PiterPy. <a href="http://hackflow.com/slides/metaprogramming/">Slides</a> and <a href="http://www.youtube.com/watch?v=Q8qxeFGNT9A">video</a> are available in russian)</em></p>

<p>Python gives us deep introspecting and metaprogramming capabilities including bytecode and AST support in the standard library. This facilitates unobvious ways to write code that writes code or otherwise alters its behavior. I will show several different examples of how it could be used for
fun and profit.</p>

<!--more-->


<h2>Warming up</h2>

<p>Look at this code:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>map(_ + 1, [1, 2, 3])
[2, 3, 4]
```</p></blockquote></blockquote></blockquote>

<p>It maps a list through <code>_ + 1</code> and gets a new list with each element incremented.
This makes sense mnemonically, but can this code actually work in python?</p>

<p>And sure it can. In fact this is rather simple trick with operator overloading:</p>

<p>```python
class Whatever(object):</p>

<pre><code>def __add__(self, y):
    return lambda x: x + y
</code></pre>

<p>_ = Whatever()
```</p>

<p>Here we create a class that produces lambda upon addition and then creates its instance named <code>_</code>.
Just using common interface in an unusual way. We can even go all loose and make something like this to work:</p>

<p>```python</p>

<h1>Sort guys by height descending</h1>

<p>sort(guys, key=&ndash;_.height)</p>

<h1>Reduce my multiplication</h1>

<p>factorial = lambda n: reduce(<em> * </em>, range(2, n+1))
```</p>

<p>Returning lambda, obviously, won&rsquo;t work anymore. However, we can return a callable object,
which also returns callables as operations results. We are also intercepting attribute access here,
shouldn&rsquo;t surprise you after everything you&rsquo;ve seen.</p>

<p>Honestly, I was too shy to use this in production. And you usually need only one or two lambdas in a file anyway, too few to bring an import, a dependency and all the complications.
But suppose you are writing <a href="https://github.com/Suor/funcy/blob/master/tests/test_funcs.py">tests for functional support library</a>,
then you&rsquo;ll need to create lots of small functions to pass them to your ones.
A library like this would be useful in that setting.</p>

<p>Anyway, if you still think this idea is too weird then you should know that there are at least 3 libraries implementing it:</p>

<ul>
<li><a href="https://github.com/Suor/whatever">whatever</a></li>
<li><a href="https://pypi.python.org/pypi/placeholder">placeholder</a></li>
<li><a href="https://github.com/kachayev/fn.py">fn.py</a></li>
</ul>


<p>But let&rsquo;s move to something more interesting.</p>

<h2>Pattern Matching</h2>

<p>Now look at this and think if it is also feasible in python.
This is supposed to recursively calculate a product of all the list elements:</p>

<p>```python
def product():</p>

<pre><code>if []: 1
if [x] + xs: x * product(xs)
</code></pre>

<p>```</p>

<p>If you familiar with pattern matching then the code makes sense:</p>

<ul>
<li>product is 1 for empty list,</li>
<li>product is (first element) times (product of the rest of the list) otherwise.</li>
</ul>


<p>On the other hand, python doesn&rsquo;t work this way. <code>x</code> and <code>xs</code> are never defined and <code>product()</code> has no arguments. And yes, this really doesn&rsquo;t work. This, however, does:</p>

<p>```python
from patterns import patterns</p>

<p>@patterns
def product():</p>

<pre><code>if []: 1
if [x] + xs: x * product(xs)
</code></pre>

<p>```</p>

<p><code>@patterns</code> here rewrites function into something we meant. It can&rsquo;t obviously be implemented as ordinary decorator, since calling original function will crash. So <code>@patterns</code> reads function code instead, parses it into abstract syntax tree, transforms that to a meaningful one and then compiles back:</p>

<p><blockquote><p>Code  →  AST  →  New AST  →  New Code</p></blockquote></p>

<!-- TODO: make it pretty -->


<p>And after transformation we get something like:</p>

<p>```python
def product(value):</p>

<pre><code>if value == []:
    return 1
if isinstance(value, list) and len(value) &gt;= 1:
    x, xs = value[0], value[1:]
    return x * product(xs)
</code></pre>

<p>```</p>

<p>Which looks like normal python code, it is also much more verbose.
That&rsquo;s why we got into this whole pattern matching thing in the first place.</p>

<p>And again it was too awkward to use all this magic in production code,
but I used code inspired by that:</p>

<p>```python</p>

<h1>Use simple pattern matching to construct form field widget</h1>

<p>TYPE_TO_WIDGET = (</p>

<pre><code>[lambda f: f.choices,           lambda f: Select(choices=f.choices)],
[lambda f: f.type == 'int',     lambda f: TextInput(coerce=int)],
[lambda f: f.type == 'string',  lambda f: TextInput()],
[lambda f: f.type == 'text',    lambda f: Textarea()],
[lambda f: f.type == 'boolean', lambda f: Checkbox(f.label)],
</code></pre>

<p>)
return first(do(field) for cond, do in TYPE_TO_WIDGET if cond(field))
```</p>

<p>This actually could be useful for many things: recursive functions, chatbots, binary protocol implementations and other occasions when you resolve to long if-elses or switch-cases.
The general idea, however, comes beyond pattern matching.</p>

<h2>AST Applications</h2>

<p>This technique &mdash; abstract syntax tree transformation &mdash; is much more broadly useful.
And the main reason is that trees capture language structure. Another trees virtue is that they are data structures, which are much more hackable than code strings.</p>

<p>Anyway, these are some things they facilitate:</p>

<p><strong>Language extensions.</strong> With pattern matching being only one of them. Other examples are optional (or not) static typing, macros, &hellip; It is only limited by your imagination and tree transformation skills. You obviously need to stay within syntax though, unless you go for separate parser and AST, but this is a separate topic.</p>

<p><strong>Optimizations</strong>. This is less obvious but we can inline calls, precalculate constant expressions, even make tail call optimization.</p>

<p><strong>Code analysis</strong>. It&rsquo;s much easier to analyze tree than just code string &lsquo;cause it captures some of semantics of a language. We can implement some linters or editor plugins with the help of AST.
Generally you won&rsquo;t need to transform a tree for analysis, but imagine some linter suggesting code changes specific to your particular fragment not general advice. That would be cool.</p>

<p><strong>Translation</strong>. To JavaScript to run things in browser, to SQL to automatically generate queries
or stored procedures, to Python 3 after all.</p>

<p>These are various ways it flows:</p>

<p><blockquote><p>Code  →  AST  →  New AST  →  New Code<br/>Code  →  AST  →  JavaScript<br/>Bytecode  →  AST  →  SQL</p></blockquote></p>

<!-- TODO: make a flowchart? -->


<p>Looks like we need to dig a bit more into AST.</p>

<h2>AST</h2>

<p>First we need a way to get a tree. The easiest way is to first get source and then parse it. Two standard modules will help us with that:</p>

<p>```python
import inspect, ast</p>

<p>source = inspect.getsource(func)
tree = ast.parse(source)
```</p>

<p>Sometimes you can&rsquo;t get function source, most common example &mdash; <code>inspect.getsource()</code> doesn&rsquo;t work with lambdas. Then you can still get to AST by decompiling bytecode:</p>

<p>```python
from meta.decompiler import decompile_func</p>

<p>tree = decompile_func(lambda x: x + 1)
```</p>

<p>We are using third party module <a href="https://github.com/srossross/Meta">meta</a> here, and despite saying that we decompile function it really does inspect and decompile its bytecode. Anyway, we&rsquo;ve got our AST, let&rsquo;s look at it:</p>

<p><img src="http://hackflow.com/slides/metaprogramming/ast-example.dot.svg" style="width: 100%"></p>

<p>This is quite a hairy tree for something as simple as <code>lambda x: x + 1</code>. But if we look at it a bit
more closer we can recognize all the corresponding parts. Left branch is arguments, which have single argument named <code>x</code>, but no kwarg, vararg or defaults. Right branch is a return node returning a result of binary operation with an op of addition and operands of a name <code>x</code> and a number <code>1</code>.</p>

<p>That makes sense, this is not however what we see as a result in python REPL:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>tree
&lt;_ast.Lambda at 0x7f7e2359e490>
```</p></blockquote></blockquote></blockquote>

<p>Yeah, it&rsquo;s just a <code>Lambda</code> object. We can look up its attributes to get other nodes:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>tree.body
&lt;_ast.Return at 0x7f3e75f869d0>
```</p></blockquote></blockquote></blockquote>

<p>And this is what python AST actually is: a collection of objects stored in the attributes of each other. In addition I need to say that this objects don&rsquo;t really have behaviour, they are just data.
You can find full list of available nodes and their attributes in <a href="https://docs.python.org/2/library/ast.html">ast module</a> documentation.</p>

<p>Inspecting AST this way could be too tiresome, we need some way to get a bigger picture.
The simplest thing we have is <code>ast.dump()</code> utility:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>print ast.dump(tree)
Lambda(args=arguments(args=[Name(id=&lsquo;x&rsquo;, ctx=Param())], vararg=None, kwarg=None,
defaults=[]), body=Return(value=BinOp(left=Name(id=&lsquo;x&rsquo;, ctx=Load()), op=Add(),
right=Num(n=1))))
```</p></blockquote></blockquote></blockquote>

<p>This is the same thing we saw in the picture, it is also useless for any non-trivial case. One more
third-party library, <a href="https://github.com/berkerpeksag/astor">astor</a>, could help us out:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>print astor.dump(tree)
Lambda(</p>

<pre><code>args=arguments(args=[Name(id='x')], vararg=None, kwarg=None, defaults=[]),
body=Return(value=BinOp(left=Name(id='x'), op=Add, right=Num(n=1))))
</code></pre>

<p>```</p></blockquote></blockquote></blockquote>

<p>The same plus indents. It is already useful when you need to look at the AST closer, but for quick print debugging python code would be even better:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>print astor.to_source(tree)
(lambda x: (x + 1))
```</p></blockquote></blockquote></blockquote>

<p>Parentheses are added everywhere to avoid dealing with operator precedence, but otherwise it&rsquo;s the same code we parsed.</p>

<p>And the last thing we usually do to AST &mdash; compile it back and execute:</p>

<p><code>python
code = compile(tree, '', 'exec')
context = {}
exec(code, globals(), context)
</code></p>

<p>Functions used here, <code>compile()</code> and <code>exec()</code>, are built-ins. And <code>code</code> is the same object type you can find introspecting <code>func.__code__</code>. By executing in a context we set all the names defined into that dict:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>context
{&lsquo;func&rsquo;: <function __main__.func>}
```</p></blockquote></blockquote></blockquote>

<p>So if all these were happening in a decorator we can get that function out of the context and substitute original one. Only the meat is left &mdash; walking the tree.</p>

<h2>AST Traversal</h2>

<p>Built-in ast module continues to aid us in this journey. It provides several utilities to ease tree walking and transformation. The lower level ones let us introspect nodes contents and iterate by them:</p>

<p>```python</p>

<h1>Iterate fields with values</h1>

<blockquote><blockquote><blockquote><p>ast.iter_fields(tree)
[(&lsquo;args&rsquo;, &lt;<em>ast.arguments at &hellip;>),
 (&lsquo;body&rsquo;, &lt;</em>ast.Return at &hellip;>)]</p></blockquote></blockquote></blockquote>

<h1>Iterate child nodes</h1>

<blockquote><blockquote><blockquote><p>ast.iter_child_nodes(tree)
[&lt;<em>ast.arguments &hellip;>, &lt;</em>ast.Return &hellip;>]</p></blockquote></blockquote></blockquote>

<h1>Just list available fields</h1>

<blockquote><blockquote><blockquote><p>tree._fields
(&lsquo;args&rsquo;, &lsquo;body&rsquo;)
```</p></blockquote></blockquote></blockquote>

<p>First of higher level ones is <code>NodeVisitor</code> &mdash; a base class implementing visitor pattern, the idea is to subclass it and define methods like <code>visit_&lt;NodeClass&gt;()</code>:</p>

<p>```python
class NumberFinder(ast.NodeVisitor):</p>

<pre><code>def visit_Num(self, node):
    print "Found number literal", node.n
</code></pre>

<p>def find_numbers(tree):</p>

<pre><code>NumberFinder().visit(tree)
</code></pre>

<p>```</p>

<p>This simple example finds all the number literals in given code. Just an example, but it could be grown into some magic number finding tool and wrapped into linter or code editor plugin.</p>

<p>The second base class ast provides is <code>NodeTransformer</code>. It works almost the same, but you can change a tree by returning new nodes from visit methods:</p>

<p>```python
class ExprOptimizer(ast.NodeTransformer):</p>

<pre><code>def visit_BinOp(self, node):
    # Call .generic_visit() to transform sub-nodes
    node = self.generic_visit(node)
    # If both operands are just numbers then precalculate
    if type(node.left) is Num and type(node.right) is Num:
        op = AST_TO_OP[node.op.__class__]
        return Num(n=op(node.left.n, node.right.n))
    else:
        return node
</code></pre>

<p>AST_TO_OP = {</p>

<pre><code>Add: operator.add,
...
</code></pre>

<p>}
```</p>

<p>This one precalculates any expressions on number literals, quite neat for just a bunch of lines.</p>

<p>And last but not least we can use old and good recursive tree walking. This snippet makes python function return last expression in a way Ruby, CoffeScript and Clojure do:</p>

<p>```python
def return_last(tree):</p>

<pre><code>if not hasattr(tree, 'body'):
    return
elif isinstance(tree.body[-1], Expr):
    tree.body[-1] = Return(value=tree.body[-1])
else:
    return_last(tree.body[-1])
</code></pre>

<p>```</p>

<p>Note this code is simplified and hence broken, e.g. it will insert <code>return</code> into the end of while loop if there is an expression there.</p>

<h2>Going Forward</h2>

<p>This was an overview of what you can do with AST, and there were lots of things. This is, however, only a preface to the actual story. Next time I will concentrate on translation and will describe it in detail capturing a real use case.</p>

<p><strong>P.S.</strong> Second part is available <a href="/blog/2015/04/12/metaprogramming-beyond-decency-part-2/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Painless Decorators]]></title>
    <link href="http://hackflow.com/blog/2013/11/03/painless-decorators/"/>
    <updated>2013-11-03T20:07:00+08:00</updated>
    <id>http://hackflow.com/blog/2013/11/03/painless-decorators</id>
    <content type="html"><![CDATA[<p>Decorators are joy to use. Write? Not so much. One needs to mess with wrappers, function metadata and a fair amount of bookkeeping. Enough things to bury any useful semantics under them. There got to be a better way.</p>

<p>Let&rsquo;s find that out.</p>

<!--more-->


<h2>Current state</h2>

<p>Currently in a decorator you need to create a wrapper, update it&rsquo;s metadata and then return it. You also need to pass arguments and result value in and out carefully. A typical pattern would be:</p>

<p>``` python
from functools import wraps</p>

<p>def some_decorator(func):</p>

<pre><code>@wraps(func)
def wrapper(*args, **kwargs):
    # ... do something before
    result = func(*args, **kwargs)
    # ... do something after
    return result
return wrapper
</code></pre>

<p>```</p>

<p>And if you want decorator with arguments it becomes even harder:</p>

<p>``` python
def some_decorator(before, after):</p>

<pre><code>def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        before()
        result = func(*args, **kwargs)
        after()
        return result
    return wrapper
return decorator
</code></pre>

<p>```</p>

<p>Look at that code for a minute. What a mess! And this is not about typing, it&rsquo;s really hard to see through to the point of it.</p>

<p>Let&rsquo;s see what is meaningful and what is a boilerplate here. What we care about is concentrated in <code>wrapper</code> function, it&rsquo;s <code>before</code> and <code>after</code> calls, how they surround original function call, what arguments are passed to it and what is returned. The name <code>some_decorator</code> and its arguments also matter. Anything else &ndash; nested functions and returns, <code>@wraps</code> and all extra indent &ndash; is just <a href="http://hackflow.com/blog/2013/10/08/abstracting-control-flow/">code pattern waiting to be abstracted</a>.</p>

<h2>Removing a boilerplate</h2>

<p>What we probably want to see (or write) is some flat syntax with code showing only wrapper semantics. Something like:</p>

<p>``` python
def some_decorator(&hellip;):</p>

<pre><code># ... do something before
result = func(*args, **kwargs)
# ... do something after
return result
</code></pre>

<p>```</p>

<p>Obviously <code>func</code>, <code>args</code> and <code>kwargs</code> should come from somewhere as well as all the magic turning plain function into decorator. Suppose we have <code>@decorator</code> to handle the conversion and the easiest way to provide all values is just enclosing them as <code>some_decorator</code> arguments:</p>

<p>``` python
@decorator
def some_decorator(func, args, kwargs):</p>

<pre><code># ... do something before
result = func(*args, **kwargs)
# ... do something after
return result
</code></pre>

<p>```</p>

<p>Calling decorated function with the same arguments as its wrapper is a pattern so common that we should abstract that too. Also, our decorator may become too cluttered once we start adding its own arguments. To keep this clean we can substitute three call related arguments with a single <code>call</code> object:</p>

<p>``` python
@decorator
def some_decorator(call):</p>

<pre><code># ... do something before
result = call()
# ... do something after
return result
</code></pre>

<p>```</p>

<p>Looks simple and to the point. Something we were looking for. And once we have a clear view we can go ahead and implement the magic. Actually, you can <a href="https://pypi.python.org/pypi/funcy">download it from pypi</a> right now and import it with <code>from funcy import decorator</code>.</p>

<h2>Advanced usage</h2>

<p>We seemingly lost a couple of features in our quest for simplicity: access to call arguments, function itself, ability to call function differently and create decorators with arguments. But that&rsquo;s not the case really, we can pack all these into <code>call</code> object. I&rsquo;ll go through everything with better examples than you saw so far.</p>

<h3>Accessing function arguments</h3>

<p>You didn&rsquo;t expect a post about decorators without logging example, did you? Anyway, it&rsquo;s an excellent way to show how you can access not only call arguments but decorated function itself:</p>

<p>``` python
@decorator
def log(call):</p>

<pre><code>print "Calling %s with args %s and kwargs %s"         \
    % (call._func.__name__, call._args, call._kwargs)
return call()
</code></pre>

<p>```</p>

<p>As you can see, everything is underscore-prefixed, this is done to avoid clashes with function argument names, the values of which are binded to <code>call</code> object as attributes. Pretty handy if you are writing something more specific than logging decorator. Look at this simplified <code>login_required</code> decorator to get a foretaste:</p>

<p>``` python
@decorator
def login_required(call):</p>

<pre><code>if call.request.user.is_authenticated():
    return call()
else:
    return redirect(LOGIN_URL)
</code></pre>

<p>```</p>

<h3>Altering calls</h3>

<p>Is considered a bad practice cause it makes code harder to read. However, this could be useful occasionally and I am not into childproofing anyway. The obvious way to do it is just using plain function carefully stored in <code>call._func</code>:</p>

<p>``` python
@decorator
def int_args(call):</p>

<pre><code>"""Coerces any function arguments to ints"""
return call._func(*map(int, call._args))
</code></pre>

<p>```</p>

<p>But a common use-case of passing some extra data to function could be written with more elegance:</p>

<p>``` python
@decorator
def with_phone(call):</p>

<pre><code>phone = Phone.objects.get(number=call.request.GET['phone'])
return call(phone) # phone is added to *args passed to decorated function
</code></pre>

<p>@with_phone
def some_view(request, phone):</p>

<pre><code># ... some code using phone
</code></pre>

<p>```</p>

<p>This works with named arguments too, and is probably a better way since you won&rsquo;t run into problems with arguments order.</p>

<h3>Decorators with arguments</h3>

<p>To get these you just add your arguments after <code>call</code> as in this <a href="http://hackflow.com/blog/2013/10/08/abstracting-control-flow/">control flow abstracting</a> retry decorator:</p>

<p>``` python
@decorator
def retry(call, tries, errors=Exception):</p>

<pre><code>for attempt in range(tries):
    try:
        return call()
    except errors:
        # Reraise error on last attempt
        if attempt + 1 == tries:
            raise
</code></pre>

<p>```</p>

<h2>Why use that?</h2>

<p>There are obvious reasons: to reduce clutter and expose your intentions. However, there is usual cost. This as any abstraction brings an additional layer of complexity on top of python. And python could be seen as a layer on top of c, and that as one above asm, and that &hellip;</p>

<p>You can choose for yourself what level is too high. And if python is sometimes not enough high level language for you then you should definitely upgrade it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Python Made Easy]]></title>
    <link href="http://hackflow.com/blog/2013/10/13/functional-python-made-easy/"/>
    <updated>2013-10-13T19:22:00+08:00</updated>
    <id>http://hackflow.com/blog/2013/10/13/functional-python-made-easy</id>
    <content type="html"><![CDATA[<p>There are a lot of buzz about Haskell, Lisp, Erlang and other languages few people code in. But while they play their role as banners, functional programming sneaks into our code in multi-paradigm languages.</p>

<p>I was going to continue this way and later introduce my library of a variety of functional tricks, but suddenly realized it&rsquo;s not about FP, it&rsquo;s about utility. And that&rsquo;s what I will focus on below trying to show you real-life value of <a href="https://github.com/Suor/funcy">funcy</a>.</p>

<!--more-->


<p>Funcy started from a try to bunch up a couple of data manipulation utils. Therefore most of my examples will be about that. Some of them may seem trivial to you, but there are many gains these tiny tools can offer you both in terms of code brevity and expressiveness. Or they&rsquo;ll just save your time, still good.</p>

<p>I&rsquo;ll go through the typical tasks any python programmer face during her day.</p>

<h2>Everyday data manipulation</h2>

<p><em>1. Flatten list of lists. That&rsquo;s how you usually do it:</em></p>

<p>``` python
from operator import concat
reduce(concat, list_of_lists)</p>

<h1>or that:</h1>

<p>sum(list_of_lists, [])</p>

<h1>or that:</h1>

<p>from itertools import chain
list(chain.from_iterable(list_of_lists))
```</p>

<p>They all work and all have their flaws: require imports, additional calls or restrict what you can pass into. But the main flaw is that they are all patterns not obvious calls. There should be a simple function to do such a simple and common thing and there is one in funcy:</p>

<p><code>python
from funcy import cat
cat(list_of_lists)
</code></p>

<p><code>cat</code> joins list of lists, tuples, iterators and generally any iterables into single list. And it comes with extra shortcut if you want to <code>cat</code> results of <code>map</code> call. For example, this</p>

<p><code>python
from funcy import mapcat
mapcat(str.splitlines, bunch_of_texts)
</code></p>

<p>will result in flat list of all lines of all the texts. There are lazy versions of both functions: <code>icat</code> and <code>imapcat</code>.</p>

<p><em>2. Merge some dicts. There are several clumsy ways in python:</em></p>

<p>``` python
d1.update(d2)  # Changes d1
dict(d1, **d2) # Really awkward for more than 2 dicts</p>

<p>d = d1.copy()
d.update(d2)
```</p>

<p>I always wondered why one can&rsquo;t just add them up, but that&rsquo;s what we have. Anyway, this is also easy in funcy:</p>

<p><code>python
from funcy import merge, join
merge(d1, d2)
merge(d1, d2, d3)
join(sequence_of_dicts)
</code></p>

<p>The best part here is these are omnivorous. They work with anything: sets, dicts, ordered dicts, lists, tuples, iterators, even strings, carefully preserving collection type.</p>

<p><em>3. Capturing something with regular expression. A usual way:</em></p>

<p>``` python
m = re.search(some_re, s)
if m:</p>

<pre><code>actual_match = m.group() # or m.group(i) or m.groups()
...
</code></pre>

<p>```</p>

<p>Much more straightforward with funcy:</p>

<p><code>python
from funcy import re_find
actual_match = re_find(some_re, s)
</code></p>

<p>Still not impressed? Then look here:</p>

<p>``` python
from funcy import re_finder, re_all, partial, mapcat</p>

<h1>Get a number out of every word</h1>

<p>map(re_finder(&lsquo;\d+&rsquo;), words)</p>

<h1>Parse simple ini file into dict</h1>

<h1>(re_finder returns tuples when there is more that one capture in regexp)</h1>

<p>dict(imap(re_finder(&lsquo;(\w+)=(\w+)&rsquo;), ini.splitlines()))</p>

<h1>Find all numbers in all the strings and return as flat list</h1>

<p>mapcat(partial(re_all, r'\d+&lsquo;), bunch_of_strings)
```</p>

<h2>About imports and practicality</h2>

<p>As you can see I import everything directly from funcy, not using any sub-packages. The reason it&rsquo;s designed this way is practicality. That would be too annoying to remember where each one tiny thing comes from. There are enough libraries to clutter your file heads anyway.</p>

<p>This also enables you to write:</p>

<p><code>python
from funcy import *
</code></p>

<p>And start enjoying all functional python niceness right away. Ok, now when you know where all the stuff is kept I won&rsquo;t repeat imports in every new example.</p>

<h2>A bit more functional things</h2>

<p>We&rsquo;ve seen a pair of examples of higher order functions earlier, particularly <code>re_finder</code> and <code>partial</code>. One thing to note is that <code>re_finder</code> itself is a partial application of <code>re_find</code> meant to be used with <code>map</code> and friends. Naturally, there is a similar utility to be used with <code>filter</code>:</p>

<p>``` python</p>

<h1>Choose all private attributes of an object</h1>

<p>is_private = re_tester(&lsquo;^_&rsquo;)
filter(is_private, dir(some_obj))
```</p>

<p>We can create a bunch of predicates and filter with them:</p>

<p><code>python
is_special = re_tester('^__.+__$')
is_const = re_tester('^[A-Z_]+$')
filter(...)
</code></p>

<p>But what if we want to apply several of them at once or use some predicate logic. That&rsquo;s easy:</p>

<p><code>python
is_public = complement(is_private)
is_private_const = all_fn(is_private, is_const)
either_const_or_public = any_fn(is_const, is_public)
</code></p>

<p>Or you can use convenience function complementary to <code>filter</code>:</p>

<p><code>python
remove(is_private, ...) # same as filter(is_public)
</code></p>

<p>I hope everyone have their functional appetite satisfied so we can switch to something less abstract.</p>

<h2>Collections</h2>

<p>Aside from <a href="http://funcy.readthedocs.org/en/latest/seqs.html">sequence utilities</a>, funcy provides lots of ones to work with collections.
And the two fundamental are <code>walk</code> and <code>select</code>, a versions of <code>map</code> and <code>filter</code> preserving collection type:</p>

<p>``` python
walk(inc, {1, 2, 3}) # &ndash;> {2, 3, 4}
walk(inc, (1, 2, 3)) # &ndash;> (2, 3, 4)</p>

<h1>Mapping function receives pairs when walking dicts</h1>

<p>swap = lambda (k, v): (v, k)
walk(swap, {1: 10, 2: 20})</p>

<h1>&ndash;> {10: 1, 20: 2}</h1>

<p>select(even, {1, 2, 3, 10, 20})</p>

<h1>&ndash;> {2, 10, 20}</h1>

<p>select(lambda (k, v): k == v, {1: 1, 2: 3})</p>

<h1>&ndash;> {1: 1}</h1>

<p>```</p>

<p>This pair of functions is backed up with a set of ones to work with dicts: <code>walk_keys</code>, <code>walk_values</code>, <code>select_keys</code>, <code>select_values</code>:</p>

<p>``` python</p>

<h1>Get a dict of public attributes of an instance</h1>

<p>select_keys(is_public, instance.<strong>dict</strong>)</p>

<h1>Clean dict of falsy values</h1>

<p>select_values(bool, some_dict)
```</p>

<p>The last example in this section will include several new functions at once: <code>silent</code> &ndash; catches all exceptions in passed function, returning <code>None</code>; <code>compact</code> &ndash; removes falsy values from collection; <code>walk_values</code> &ndash; maps dict values with given function. Anyhow, this line constructs a dict of integer params from typical stringy request dict you get:</p>

<p><code>python
compact(walk_values(silent(int), request_dict))
</code></p>

<h2>Back to data manipulation</h2>

<p>Finally, the interesting part. I included some examples here just because they seem cool. Although, I did this earlier to be honest. Anyway, let&rsquo;s split and group:</p>

<p>``` python</p>

<h1>split absolute and relative urls</h1>

<p>absolute, relative = split(re_tester(r'^<a href="http://">http://</a>&lsquo;), urls)</p>

<h1>group posts by category</h1>

<p>group_by(lambda post: post.category, posts)
```</p>

<p>Partition and chunk:</p>

<p>``` python</p>

<h1>make a dict from flat list of pairs</h1>

<p>dict(partition(2, flat_list_of_pairs))</p>

<h1>make a structures from flat list</h1>

<p>{id: (name, password) for id, name, password in partition(3, users)}</p>

<h1>check versions are consecutive</h1>

<p>assert all(prev + 1 == next for prev, next in partition(2, 1, versions)):</p>

<h1>process data by chunks</h1>

<p>for chunk in chunks(CHUNK_SIZE, lots_of_data):</p>

<pre><code>process(chunk)
</code></pre>

<p>```</p>

<p>And a couple more, just for fun:</p>

<p>``` python</p>

<h1>add new line indents at the beginning of each paragraph</h1>

<p>for line, prev in with_prev(text.splitlines()):</p>

<pre><code>if not prev:
    print '    ',
print line
</code></pre>

<h1>select Shakespeare&rsquo;s play written in 1611</h1>

<p>where(plays, author=&ldquo;Shakespeare&rdquo;, year=1611)</p>

<h1>=> [{&ldquo;title&rdquo;: &ldquo;Cymbeline&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611},</h1>

<h1>{&ldquo;title&rdquo;: &ldquo;The Tempest&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611}]</h1>

<p>```</p>

<h2>More than just a library</h2>

<p>Maybe some of you recognized some functions from Clojure or Underscore.js (Shakespear example was shamelessly ripped of the docs of the latter, for example). That should not surprise you, in many respects I drew inspiration from these two sources. Nonetheless I followed python spirit and stayed practical as far as I could.</p>

<p>And one more thought. We used to call programming languages languages, still rarely think of keywords and functions as words. We define our own words by writing new functions, but they are usually too specific to make it into our everyday use. Funcy utilities are designed the other way around, to be broadly used as a layer over python and it&rsquo;s standard library.</p>

<p>So, how about <a href="https://github.com/Suor/funcy">extending your vocabulary</a>?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abstracting Control Flow]]></title>
    <link href="http://hackflow.com/blog/2013/10/08/abstracting-control-flow/"/>
    <updated>2013-10-08T12:13:00+08:00</updated>
    <id>http://hackflow.com/blog/2013/10/08/abstracting-control-flow</id>
    <content type="html"><![CDATA[<p>Any programmer, even if she doesn&rsquo;t see it this way, constantly creates abstractions. The most common things we abstract are calculations (caught into functions) or behavior (procedures and classes), but there are other recurring patterns in our work, especially in error handling, resource management and optimizations.</p>

<p>Those recurring patterns usually involve rules like &ldquo;close everything you open&rdquo;, &ldquo;free resources then pass error farther&rdquo;, &ldquo;if that succeeded go on else &hellip;&rdquo;, which commonly look like repetitive <code>if ... else</code> or <code>try ... catch</code> code. How about abstracting all that control flow?</p>

<p> <!--more--></p>

<p>In conventional code, where nobody plays too smart, control structures do control flow. Sometimes they don&rsquo;t do that well and then we throw in our own. That is simple in Lisp, Ruby or Perl, but is also possible in a way in any language featuring higher order functions.</p>

<h2>Abstractions</h2>

<p>Let&rsquo;s start from the beginning. What do we do to build a new abstraction?</p>

<ol>
<li>Select a piece of functionality or behavior.</li>
<li>Name it.</li>
<li>Implement it.</li>
<li>Hide our implementation behind chosen name.</li>
</ol>


<p>Points 3-4 are not always possible. It depends very much on flexibility of your language and the piece you are trying to abstract.</p>

<p>In case your language can&rsquo;t handle it, skip implementation and just describe your technique, make it popular, giving birth to a new design pattern. This way you can continue writing repetitive code without feeling bad about it.</p>

<h2>Back to real-life</h2>

<p>This is a piece of common python code, taken from real-life project with minimal changes:</p>

<p>``` python
urls = &hellip;
photos = []</p>

<p>for url in urls:</p>

<pre><code>for attempt in range(DOWNLOAD_TRIES):
    try:
        photos.append(download_image(url))
        break
    except ImageTooSmall:
        pass # skip small images
    except (urllib2.URLError, httplib.BadStatusLine, socket.error), e:
        if attempt + 1 == DOWNLOAD_TRIES:
            raise
</code></pre>

<p>```</p>

<p>There are many aspects to this code: iterating over <code>urls</code>, downloading images, collecting images into <code>photos</code>, skipping small images and retries in case of download errors. All of them are entangled in this single piece of code, despite that they can be useful outside of this code snippet.</p>

<p>And some of them already exist separately. For example, iteration plus result gathering make <code>map</code>:</p>

<p><code>python
photos = map(download_image, urls)
</code></p>

<p>Let&rsquo;s try fishing out other aspects, starting with skipping small images. That could be done like:</p>

<p>``` python
@contextmanager
def ignore(error):</p>

<pre><code>try:
    yield
except error:
    pass
</code></pre>

<p>photos = []
for url in urls:</p>

<pre><code>with ignore(ImageTooSmall):
    photos.append(download_image(url))
</code></pre>

<p>```</p>

<p>Looks good. However this can&rsquo;t be composed with <code>map</code> easily. But let&rsquo;s put it off for now and deal with network errors. We can try abstracting it the same way we handled <code>ignore</code>:</p>

<p>``` python
with retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error)):</p>

<pre><code># ... do stuff
</code></pre>

<p>```</p>

<p>Only that can&rsquo;t be implemented. Python <code>with</code> statement can&rsquo;t run its block more than once. We just ran against language constraint. It&rsquo;s important to notice such cases if you want to understand languages differences beyond syntax. In Ruby and to lesser extend in Perl we could continue manipulating blocks, in Lisp we could even manipulate code (that would probably be an overkill), but not all is lost for Python, we should just switch to higher order functions and their convenience concept &ndash; decorators:</p>

<p>``` python
@decorator
def retry(call, tries, errors=Exception):</p>

<pre><code>for attempt in range(tries):
    try:
        return call()
    except errors:
        if attempt + 1 == tries:
            raise
</code></pre>

<p>http_retry = retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error))
photos = map(http_retry(download_image), urls)
```</p>

<p>As we can see, it even works with <code>map</code> naturally. And more than that, we got a pair of potentially reusable tools: <code>retry</code> and <code>http_retry</code>. Unfortunately our <code>ignore</code> context manager can&rsquo;t be easily added here. It&rsquo;s not composable. Let&rsquo;s just rewrite it as decorator:</p>

<p>``` python
@decorator
def ignore(call, errors=Exception):</p>

<pre><code>try:
    return call()
except errors:
    return None
</code></pre>

<p>ignore_small = ignore(ImageTooSmall)
http_retry = retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error))
download = http_retry(ignore_small(download_image))
photos = filter(None, map(download, urls))
```</p>

<h2>How is this better?</h2>

<p>Seems like we have more code now and it still involves all the same aspects. The difference is that they are not entangled anymore they are composed. Which means several things:</p>

<ul>
<li>every single aspect is visible,</li>
<li>it&rsquo;s named,</li>
<li>it can be taken out and brought back easily,</li>
<li>it can be reused.</li>
</ul>


<p>The essential code takes only 4 last lines and after getting used to functional control flow can probably become more readable. Or not, that&rsquo;s subjective. Still I hope this post will help somebody to write better code.</p>

<p><strong>P.S.</strong> I packed <code>@decorator</code>, <code>ignore</code> and <code>retry</code> into <a href="https://github.com/Suor/funcy">one practical library</a>.</p>

<p><strong>P.P.S.</strong> Other examples of control flow abstractions include: <a href="http://underscorejs.org/#functions">function manipulations in underscore.js</a>, list comprehensions and generator expressions, <a href="https://github.com/Suor/patterns">pattern matching</a>, <a href="https://github.com/Suor/overload">function overload</a>, caching decorators and much more.</p>
]]></content>
  </entry>
  
</feed>
