<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Hackflow]]></title>
  <link href="http://hackflow.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://hackflow.com/"/>
  <updated>2013-10-08T18:01:30+08:00</updated>
  <id>http://hackflow.com/</id>
  <author>
    <name><![CDATA[Alexander Schepanovski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Abstracting Control Flow]]></title>
    <link href="http://hackflow.com/blog/2013/10/08/abstracting-control-flow/"/>
    <updated>2013-10-08T12:13:00+08:00</updated>
    <id>http://hackflow.com/blog/2013/10/08/abstracting-control-flow</id>
    <content type="html"><![CDATA[<p>Any programmer, even if she doesn&rsquo;t see it this way, constantly creates abstractions. The most common things we abstract are calculations (caught into functions) or behavior (procedures and classes), but there are other recurring patterns in our work, especially, in error handling, resource management and optimizations.</p>

<p>That recurring patterns usually involve rules like &ldquo;close everything you open&rdquo;, &ldquo;free resources then pass error farther&rdquo;, &ldquo;if that succeed go on else &hellip;&rdquo;, which usually involve repetitive <code>if ... else</code> or <code>try ... catch</code> code. How about abstracting all these control flow?</p>

<p>In conventional code, where nobody plays too smart, control structures do control flow. Sometimes they don&rsquo;t do that well and then we through in our own. That is simple in Lisp, Ruby or Perl, but also possible in a way in any language featuring higher order functions.</p>

<h2>Abstractions</h2>

<p>Let&rsquo;s start from the beginning. What do we do to build new abstraction?</p>

<ol>
<li>Select a piece of functionality or behavior.</li>
<li>Name it.</li>
<li>Implement it.</li>
<li>Hide our implementation behind chosen name.</li>
</ol>


<p>Points 3-4 are not always possible. It depends very much on flexibility of your language and the piece you are trying to abstract.</p>

<p>In case your language can&rsquo;t handle it, skip implementation and just describe your technique, make it popular, giving birth to new design pattern. This way you can continue writing repetitive code without feeling bad about it.</p>

<h2>Back to real-life</h2>

<p>This is common python code, taken from real-life project with minimal changes:</p>

<p>``` python
urls = &hellip;
photos = []</p>

<p>for url in urls:</p>

<pre><code>for attempt in range(DOWNLOAD_TRIES):
    try:
        photos.append(download_image(url))
        break
    except ImageTooSmall:
        pass # skip small images
    except (urllib2.URLError, httplib.BadStatusLine, socket.error), e:
        if attempt + 1 == DOWNLOAD_TRIES:
            raise
</code></pre>

<p>```</p>

<p>There are many aspects to this code: iteration over <code>urls</code>, image download, collecting images into <code>photos</code>, skipping small images, retries in case of download errors. All of them are entangled in this single piece of code, despite that they can be useful outside of this code snippet.</p>

<p>And some of them already exist separately. For example, iteration plus result gathering make <code>map</code>:</p>

<p><code>python
photos = map(download_image, urls)
</code></p>

<p>Let&rsquo;s try fishing out other aspects, starting with skipping small images. That could be done like:</p>

<p>``` python
@contextmanager
def ignore(error):</p>

<pre><code>try:
    yield
except error:
    pass
</code></pre>

<p>photos = []
for url in urls:</p>

<pre><code>with ignore(ImageTooSmall):
    photos.append(download_image(url))
</code></pre>

<p>```</p>

<p>Looks good. However this can&rsquo;t be composed with <code>map</code> easily. But let&rsquo;s put it off for now and deal with network errors. We can try abstracting it same way we handled <code>ignore</code>:</p>

<p>``` python
with retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error)):</p>

<pre><code># ... do stuff
</code></pre>

<p>```</p>

<p>Only that can&rsquo;t be implemented. Pythons <code>with</code> statement can&rsquo;t run it&rsquo;s block more than once. We just ran against language constraint. It&rsquo;s important to notice such cases if you want to understand languages differences beyond syntax. In Ruby and to lesser extend in Perl we could continue manipulating blocks, in Lisp we could even manipulate code (that will probably be an overkill), but not all is lost for Python, we should just switch to higher order functions and their convenience concept &ndash; decorators:</p>

<p>``` python
@decorator
def retry(call, tries, errors=Exception):</p>

<pre><code>for attempt in range(tries):
    try:
        return call()
    except errors:
        if attempt + 1 == tries:
            raise
</code></pre>

<p>http_retry = retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error))
photos = map(http_retry(download_image), urls)
```</p>

<p>As we can see, it even works with map naturally. And more than that, we got a pair of potentially reusable tools: <code>retry</code> and <code>http_retry</code>. Unfortunately our <code>ignore</code> context manager can&rsquo;t be easily added here. It&rsquo;s not composable. Let&rsquo;s just rewrite it as decorator:</p>

<p>``` python
@decorator
def ignore(call, errors=Exception):</p>

<pre><code>try:
    return call()
except errors:
    return None
</code></pre>

<p>ignore_small = ignore(ImageTooSmall)
http_retry = retry(DOWNLOAD_TRIES, (urllib2.URLError, httplib.BadStatusLine, socket.error))
download = http_retry(ignore_small(download_image))
photos = filter(None, map(download, urls))
```</p>

<h2>How is this better?</h2>

<p>Seems like we have more code now and it still involves all the same aspects. The difference is that they are not entangled anymore they are composed. That means several things:</p>

<ul>
<li>every single aspect is visible,</li>
<li>it&rsquo;s named,</li>
<li>it can be taken out and brought back easily,</li>
<li>it can be reused.</li>
</ul>


<p>The essential code takes only 4 last lines and after getting used to functional control flow has probably become more readable. Or not, that&rsquo;s subjective, still I hope this post will help somebody to write better code.</p>

<p><strong>P.S.</strong> I packed <code>@decorator</code>, <code>ignore</code> and <code>retry</code> into <a href="https://github.com/Suor/funcy">one practical library</a>.</p>

<p><strong>P.P.S.</strong> Other examples of control flow abstractions include: <a href="http://underscorejs.org/#functions">function manipulations in underscore.js</a>, list comprehensions and generator expressions, <a href="https://github.com/Suor/patterns">pattern matching</a>, <a href="https://github.com/Suor/overload">function overload</a>, caching decorators and much more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Python Made Easy]]></title>
    <link href="http://hackflow.com/blog/2013/10/07/functional-python-made-easy/"/>
    <updated>2013-10-07T18:02:00+08:00</updated>
    <id>http://hackflow.com/blog/2013/10/07/functional-python-made-easy</id>
    <content type="html"><![CDATA[<p>Вот уже несколько лет функциональное программирование набирает популярность. Это, конечно, не значит, что люди забрасывают свои старые языки и ООП и массово переходят на Haskell, Lisp или Erlang. Нет. Функциональная парадигма проникает в наш код через лазейки мультипарадигменных языков, а вышеупомянутые языки чаще служат флагами в этом наступлении, чем используются непосредственно.</p>

<p>Я собирался продолжить в том же духе и во второй части статьи представить <a href="http://github.com/Suor/funcy">свою библиотеку</a>, добавляющую пару функциональных трюков в python, но потом понял, что фокус моей библиотеки не на функциональном программировании, а на практичности. На этом я и сосредоточюсь, приведу несколько жизненных примеров полезности funcy.
<habracut />
Разработка funcy началась с попытки собрать в кучу несколько утилит для манипулирования данными и реже функциями, поэтому большинство моих примеров будут сосредоточены именно на этом. Возможно, некоторые (или многие) примеры покажутся тривиальными, но удивительно сколько времени могут сэкономить такие простые функции и насколько более выразительным они могут сделать ваш код.</p>

<p>Я пройдусь по нескольким типичным задачам, которые встречаются в питоньей практике, и несмотря на свою незамысловатость, вызывают постоянные вопросы. Итак, поехали.</p>

<h2>Несложные манипуляции с данными</h2>

<p><em>1. Объединить список списков. Традиционно я делал это таким образом:</em></p>

<p>``` python
from operator import concat
reduce(concat, list_of_lists)</p>

<h1>Или таким:</h1>

<p>sum(list_of_lists, [])</p>

<h1>Или таким:</h1>

<p>from itertools import chain
list(chain.from_iterable(list_of_lists))
```</p>

<p>Все они неплохи, но требуют либо лишних телодвижений: импорты и дополнительные вызовы, либо накладывают ограничения: объединять можно только списки со списками и туплы с туплами, для суммы нужно ещё знать заранее какой тип придёт. В funcy это делается так:</p>

<p><code>python
from funcy import cat
cat(list_of_lists)
</code>
<code>cat()</code> объединяет список списков, кортежей, итераторов да и вообще любых итерируемых в один список. Если нужно объединить списки результатов вызова функции, то можно воспользоваться <code>mapcat()</code>, например:</p>

<p><code>python
from funcy import mapcat
mapcat(str.splitlines, bunch_of_texts)
</code>
разберёт все строки в текстах в один плоский список. Для обеих функций есть ленивые версии: <code>icat()</code> и <code>imapcat()</code>.</p>

<p><em>2. Сложить несколько словарей. В питоне есть несколько неуклюжих способов объединять словари:</em></p>

<p>``` python
d1.update(d2)  # Изменяет d1
dict(d1, **d2) # Неудобно для > 2 словарей</p>

<p>d = d1.copy()
d.update(d2)
```
Я всегда удивлялся почему их нельзя просто сложить? Но имеем то, что имеем. В любом случае, с funcy это делается легко:</p>

<p><code>python
from funcy import merge, join
merge(d1, d2)
merge(d1, d2, d3)
join(sequence_of_dicts)
</code>
Но <code>merge()</code> и <code>join()</code> могут объединять не только словари, они работают практически для любых коллекций: словарей, упорядоченных словарей, множеств, списков, кортежей, итераторов и даже строк.</p>

<p><em>3. Захват подстроки с помощью регулярного выражения. Обычно это делается так:</em></p>

<p>``` python
m = re.search(some_re, s)
if m:</p>

<pre><code>actual_match = m.group() # или m.group(i), или m.groups()
...
</code></pre>

<p>```
С funcy это превращается в:</p>

<p><code>python
from funcy import re_find
actual_match = re_find(some_re, s)
</code>
Если это не кажется вам достаточно впечатляющим, то взгляните на это:</p>

<p>``` python
from funcy import re_finder, re_all, partial, mapcat</p>

<h1>Вычленяем числа из каждого слова</h1>

<p>map(re_finder(&lsquo;\d+&rsquo;), words)</p>

<h1>Парсим ini файл (re_finder() возвращает кортежи когда в выражении > 1 захвата)</h1>

<p>dict(imap(re_finder(&lsquo;(\w+)=(\w+)&rsquo;), ini.splitlines()))</p>

<h1>Вычленяем числа из строк (возможно по нескольку из каждой) и объединяем в плоский список</h1>

<p>mapcat(partial(re_all, r'\d+&lsquo;), bunch_of_strings)
```</p>

<h2>Отступление про импорты и практичность</h2>

<p>Как вы могли заметить, я импортирую функции напрямую из funcy, не используя какие-либо подпакеты. Причина, по которой я остановился на таком интерфейсе, &ndash; практичность; было бы довольно занудным требовать от всех пользователей моей библиотеки помнить откуда нужно импортировать walk() из funcy.colls или funcy.seqs, кроме того, многострочные импорты в начале каждого файла и без меня есть кому набивать.</p>

<p>Дополнительным преимуществом такого решения является возможность просто написать:</p>

<p><code>python
from funcy import *
</code></p>

<p>И наслаждаться всеми функциональными прелестями и удобством, что приносит funcy, более не возвращаясь в начало файла за добавкой. Что ж, теперь, когда вы знаете где лежит всё добро, я больше не буду явно указывать импорты из funcy. Продолжим.</p>

<h2>Кое-какие более функциональные штучки</h2>

<p>Мы уже видели пару примеров использования функций высшего порядка &ndash; <code>re_finder()</code> и <code>partial()</code>. Стоит добавить, что сама функция <code>re_finder()</code> является частичным применением <code>re_find()</code> созданным для удобства применения в <code>map()</code> и ей подобных. И естественным образом, с <code>filter()</code> удобно использовать <code>re_tester()</code>:</p>

<p>``` python</p>

<h1>Выбираем все приватные атрибуты объекта</h1>

<p>is_private = re_tester(&lsquo;^_&rsquo;)
filter(is_private, dir(some_obj))
```</p>

<p>Отлично, мы можем задать несколько предикатов, таких как <code>is_private()</code>, и фильтровать атрибуты объекта по ним:</p>

<p><code>python
is_special = re_tester('^__.+__$')
is_const = re_tester('^[A-Z_]+$')
filter(...)
</code>
Но, что если мы хотим получить список публичных атрибутов или приватных констант, что-то задействующее комбинацию предикатов? Легко:</p>

<p><code>python
is_public = complement(is_private)
is_private_const = all_fn(is_private, is_const)
either_const_or_public = any_fn(is_const, is_public)
</code>
Для удобства также есть функция, дополняющая <code>filter()</code>:</p>

<p><code>python
remove(is_private, ...) # то же, что filter(is_public)
</code>
Надеюсь все утолили свой функциональный аппетит, потому пора перейти к чему-нибудь менее абстрактному.</p>

<h2>Работа с коллекциями</h2>

<p>Кроме утилит для работы с последовательностями, <a href="http://funcy.readthedocs.org/en/latest/seqs.html">коих много больше</a>, чем я тут описал, funcy также помогает работать с коллекциями. Основу составляют функции <code>walk()</code> и <code>select()</code>, которые аналогичны <code>map()</code> и <code>filter()</code>, но сохраняют тип обрабатываемой коллекции:</p>

<p>``` python
walk(inc, {1, 2, 3}) # &ndash;> {2, 3, 4}
walk(inc, (1, 2, 3)) # &ndash;> (2, 3, 4)</p>

<h1>при обработке словаря мы работаем с парами ключ-значение</h1>

<p>swap = lambda (k, v): (v, k)
walk(swap, {1: 10, 2: 20})</p>

<h1>&ndash;> {10: 1, 20: 2}</h1>

<p>select(even, {1, 2, 3, 10, 20})</p>

<h1>&ndash;> {2, 10, 20}</h1>

<p>select(lambda (k, v): k == v, {1: 1, 2: 3})</p>

<h1>&ndash;> {1: 1}</h1>

<p>```
Эта пара функций подкрепляется набором для работы со словарями: <code>walk_keys(), walk_values(), select_keys(), select_values()</code>:</p>

<p>``` python</p>

<h1>выберем публичную часть словаря атрибутов объекта</h1>

<p>select_keys(is_public, instance.<strong>dict</strong>)</p>

<h1>выбросим ложные значения из словаря</h1>

<p>select_values(bool, some_dict)
```
Последний пример из этой серии будет использовать сразу несколько новых функций: <code>silent()</code> &ndash; глушит все исключения, бросаемые оборачиваемой функцией, возвращая <code>None</code>; <code>compact()</code> &ndash; убирает из коллекции значения <code>None</code>; <code>walk_values()</code> &ndash; обходит значения переданного словаря, конструируя новый словарь с значениями, преобразованными переданной функцией. В целом эта строка выбирает словарь целочисленных параметров из параметров запроса:</p>

<p><code>python
compact(walk_values(silent(int), request_dict))
</code></p>

<h2>Манипулирование данными</h2>

<p>О! Мы добрались до самого интересного, сюда часть примеров я включил просто потому, что они кажутся мне клёвыми. Хотя, если честно, я делал это и выше. Сейчас мы будем разделять и группировать:</p>

<p>``` python</p>

<h1>отделим абсолютные URL от относительных</h1>

<p>absolute, relative = split(re_tester(r'^<a href="http://">http://</a>&lsquo;), urls)</p>

<h1>группируем посты по категории</h1>

<p>group_by(lambda post: post.category, posts)
```
Собирать плоские данные во вложенные структуры:</p>

<p>``` python</p>

<h1>строим словарь из плоского списка пар</h1>

<p>dict(partition(2, flat_list_of_pairs))</p>

<h1>строим структуру учётных данных</h1>

<p>{id: (name, password) for id, name, password in partition(3, users)}</p>

<h1>проверяем, что список версий последователен</h1>

<p>assert all(prev + 1 == next for prev, next in partition(2, 1, versions)):</p>

<h1>обрабатываем данные кусками</h1>

<p>for chunk in chunks(CHUNK_SIZE, lots_of_data):</p>

<pre><code>process(chunk)
</code></pre>

<p>```
И ещё пара примеров, просто до кучи:</p>

<p>``` python</p>

<h1>выделяем абзацы красной строкой</h1>

<p>for line, prev in with_prev(text.splitlines()):</p>

<pre><code>if not prev:
    print '    ',
print line
</code></pre>

<h1>выбираем пьесы Шекспира за 1611 год</h1>

<p>where(plays, author=&ldquo;Shakespeare&rdquo;, year=1611)</p>

<h1>=> [{&ldquo;title&rdquo;: &ldquo;Cymbeline&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611},</h1>

<h1>{&ldquo;title&rdquo;: &ldquo;The Tempest&rdquo;, &ldquo;author&rdquo;: &ldquo;Shakespeare&rdquo;, &ldquo;year&rdquo;: 1611}]</h1>

<p>```</p>

<h2>Не просто библиотека</h2>

<p>Возможно, некоторые из вас встретили знакомые функции из Clojure и Underscore.js (кстати, пример с Шекспиром нагло содран из документации последней), &ndash; ничего удивительного, я во многом черпал вдохновение из этих источников. При этом я старался следовать питоньему стилю, сохранять консистентность библиотеки и нигде не жертвовать практичностью, поэтому не все функции полностью соответствуют своим прототипам, они скорее соответствуют друг другу и стандартной библиотеке.</p>

<p>И ещё одна мысль. Мы привыкли называть языки программирования языками, при этом редко осознаём, что синтаксические конструкции и стандартные функции &ndash; это слова этих языков. Мы можем добавлять свои слова, определяя функции, но обычно такие слова слишком специфичны, чтобы попасть в повседневный языковой словарь. Утилиты из funcy, напротив, заточены под широкую область применения, поэтому эту библиотеку можно воспринимать как расширение python, также как underscore или jQuery &ndash; расширение JavaScript. Итак, всем кто хочет пополнить свой словарный запас &ndash; <a href="http://github.com/Suor/funcy">добро пожаловать</a>.</p>
]]></content>
  </entry>
  
</feed>
